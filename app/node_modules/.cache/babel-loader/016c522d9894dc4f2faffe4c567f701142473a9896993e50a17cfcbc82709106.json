{"ast":null,"code":"// Counter to generate unique IDs for curved paths\nlet pathIdCounter = 0;\nexport class FAAddAllInstruction {\n  constructor(graph) {\n    this.graph = void 0;\n    this.graph = graph;\n    pathIdCounter = 0;\n  }\n  async process(svg) {\n    const nodeTransitions = [];\n    const labelTransitions = [];\n    const linesGroup = svg.append(\"g\").attr(\"id\", \"lines\");\n    const layoutCenterX = 350;\n    const layoutCenterY = 200;\n    const nodesGroup = svg.append(\"g\");\n    let indexNodes = new Map();\n    let index = 0;\n    const total = this.graph.get_nodes().size;\n\n    // Draw all nodes\n    this.graph.get_nodes().forEach((node, value) => {\n      const pos = this.getPosition(index, total, layoutCenterX, layoutCenterY);\n      const is_starting_node = this.graph.is_starting_node(value);\n      const is_final_node = this.graph.is_final_node(value); // Get the final node status\n\n      // Create the node(s) and get the selections\n      const nodeSelections = this.createNode(nodesGroup, pos.x, pos.y, 20, \"node\", 0, is_final_node);\n      const label = this.createLabel(nodesGroup, pos, value);\n\n      // Apply transition to both the main circle and the outer ring\n      const node_transition = this.applyNodeTransition(nodeSelections.mainCircle, nodeSelections.outerRing, pos);\n      const label_transition = this.applyLabelTransition(label, pos);\n      indexNodes.set(value, [index++, nodeSelections.mainCircle]);\n      nodeTransitions.push(node_transition);\n      labelTransitions.push(label_transition);\n\n      // If node is a starting state, add a line to it pointing away from the center\n      if (is_starting_node) {\n        const startNodePos = pos;\n\n        // Vector from layout center to starting node\n        const vx = startNodePos.x - layoutCenterX;\n        const vy = startNodePos.y - layoutCenterY;\n\n        // Normalize the vector\n        const magnitude = Math.sqrt(vx * vx + vy * vy);\n        let unitVx = magnitude === 0 ? 0 : vx / magnitude;\n        let unitVy = magnitude === 0 ? 0 : vy / magnitude;\n        const angleDegrees = 80;\n        const angleRadians = angleDegrees * (Math.PI / 180);\n        const rotatedVx = unitVx * Math.cos(angleRadians) - unitVy * Math.sin(angleRadians);\n        const rotatedVy = unitVx * Math.sin(angleRadians) + unitVy * Math.cos(angleRadians);\n        const arrowLength = 50;\n\n        // Arrow start (offset from the node in rotated direction)\n        const arrowStartX = startNodePos.x + rotatedVx * arrowLength;\n        const arrowStartY = startNodePos.y + rotatedVy * arrowLength;\n\n        // Arrow end at the node\n        const arrowEndX = startNodePos.x;\n        const arrowEndY = startNodePos.y;\n        this.createLine(value, \"\", linesGroup, {\n          x: arrowStartX,\n          y: arrowStartY\n        }, {\n          x: arrowEndX,\n          y: arrowEndY\n        });\n      }\n    });\n\n    // Draw connectors\n    this.graph.get_nodes().forEach((node, value) => {\n      let pointers = this.graph.get_pointers(value);\n      if (pointers != null && pointers.size > 0) {\n        const entry = indexNodes.get(value);\n        if (!entry) return; // safety check\n\n        const [index, currentNode] = entry;\n        const current_node_pos = this.getPosition(index, total, 350, 200);\n        pointers.forEach((weights, pointer) => {\n          const targetEntry = indexNodes.get(pointer.get_value());\n          if (!targetEntry) return;\n          const [targetIndex, _] = targetEntry;\n          const target_node_pos = this.getPosition(targetIndex, total, 350, 200);\n\n          // Loop arrow back to self - if value and pointer are equal\n          if (value == pointer.get_value()) {\n            // Calculate angle of the node from the layout center\n            const nodeAngle = Math.atan2(current_node_pos.y - layoutCenterY, current_node_pos.x - layoutCenterX);\n            const loopRadius = 40;\n            const angleOffset = Math.PI / 6;\n            let startAngleRad, endAngleRad;\n            startAngleRad = nodeAngle - angleOffset;\n            endAngleRad = nodeAngle + angleOffset;\n\n            // Calculate start and end points on the node's circumference\n            const startX = current_node_pos.x + 20 * Math.cos(startAngleRad);\n            const startY = current_node_pos.y + 20 * Math.sin(startAngleRad);\n            const endX = current_node_pos.x + 20 * Math.cos(endAngleRad);\n            const endY = current_node_pos.y + 20 * Math.sin(endAngleRad);\n\n            // Calculate control point for the arc\n            // Position the control point further out along the radial direction\n            const controlPointDistance = 20 + loopRadius * 2;\n            const controlX = current_node_pos.x + controlPointDistance * Math.cos(nodeAngle);\n            const controlY = current_node_pos.y + controlPointDistance * Math.sin(nodeAngle);\n\n            // SVG path data for a self-loop using a quadratic bezier curve (Q)\n            const pathData = `M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;\n            const uniqueId = `line-${value}-${pointer.get_value()}`;\n            let defs = linesGroup.select(\"defs\");\n            if (defs.empty()) {\n              defs = linesGroup.append(\"defs\");\n            }\n            defs.append(\"marker\").attr(\"id\", `arrow-${value}-${pointer.get_value()}`).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 28).attr(\"refY\", 5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto-start-reverse\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\", \"black\");\n            const selfLoopPath = linesGroup.append(\"path\").attr(\"id\", uniqueId).attr(\"d\", pathData).attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"marker-end\", `url(#arrow-${value}-${pointer.get_value()})`);\n\n            // Create label for the self-loop\n            this.createLineLabel(linesGroup, selfLoopPath, weights);\n          } else if (this.hasMutualPointer(value, pointer.get_value())) {\n            const curvedPath = this.createCurvedLine(value, pointer.get_value(), linesGroup, current_node_pos, target_node_pos, 0.12);\n            this.createLineLabel(linesGroup, curvedPath, weights);\n          } else {\n            const straightLine = this.createLine(value, pointer.get_value(), linesGroup, current_node_pos, target_node_pos);\n            this.createLineLabel(linesGroup, straightLine, weights);\n          }\n        });\n      }\n    });\n    await Promise.all([...nodeTransitions, ...labelTransitions]);\n  }\n\n  // Creates a label for a line (edge) {Mostly generated through gpt and gemini -- edited by michael}\n  createLineLabel(group, lineOrPath, txts) {\n    const isLine = lineOrPath.node() instanceof SVGLineElement;\n    const createdLabels = [];\n    txts.forEach((txt, index) => {\n      // Append a text element for each weight\n      const text = group.append(\"text\").style(\"fill\", \"red\").style(\"font-size\", \"16px\").style(\"pointer-events\", \"none\");\n      if (isLine) {\n        const line = lineOrPath;\n        const x1 = parseFloat(line.attr(\"x1\"));\n        const y1 = parseFloat(line.attr(\"y1\"));\n        const x2 = parseFloat(line.attr(\"x2\"));\n        const y2 = parseFloat(line.attr(\"y2\"));\n\n        // Calculate midpoint\n        const midX = (x1 + x2) / 2;\n        const midY = (y1 + y2) / 2 - 10;\n\n        // Calculate perpendicular offset\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const lineLength = Math.sqrt(dx * dx + dy * dy);\n        // Add a small check for zero length to avoid division by zero\n        const offsetX = lineLength === 0 ? 0 : -dy / lineLength;\n        const offsetY = lineLength === 0 ? 0 : -dx / lineLength;\n\n        // Adjust position based on the index for multiple labels\n        const labelSpacing = 15; // Adjust this value for desired spacing\n        const totalOffset = (index - (txts.length - 1) / 2) * labelSpacing; // Center the labels around the midpoint\n\n        text.attr(\"x\", midX + offsetX * totalOffset).attr(\"y\", midY + offsetY * totalOffset).attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").text(txt);\n      } else {\n        const path = lineOrPath;\n        const pathId = path.attr(\"id\");\n\n        // Adjust startOffset for each label along the curve\n        const startOffset = 80 - (txts.length - 1) * 2 + (index - (txts.length - 1) / 2) * 5;\n        text.append(\"textPath\").attr(\"xlink:href\", `#${pathId}`).attr(\"startOffset\", `${startOffset}%`).attr(\"text-anchor\", \"middle\").text(txt);\n      }\n      createdLabels.push(text);\n    });\n    return createdLabels;\n  }\n  hasMutualPointer(from, to) {\n    const fromPointers = this.graph.get_pointers(from);\n    const toPointers = this.graph.get_pointers(to);\n    if (!fromPointers || !toPointers) return false;\n\n    // Compare the node values (not the FA_Node instances)\n    const fromPointsTo = Array.from(fromPointers.keys()).some(p => p.get_value() === to);\n    const toPointsTo = Array.from(toPointers.keys()).some(p => p.get_value() === from);\n    return fromPointsTo && toPointsTo;\n  }\n  createCurvedLine(nodeFrom, nodeTo, group, from, to, curvature = 0.3) {\n    // Midpoint between from and to\n    const midX = (from.x + to.x) / 2;\n    const midY = (from.y + to.y) / 2;\n\n    // Offset for the curve (perpendicular to the line)\n    const dx = to.x - from.x;\n    const dy = to.y - from.y;\n    const norm = Math.sqrt(dx * dx + dy * dy);\n    const offsetX = -dy * curvature;\n    const offsetY = dx * curvature;\n    const controlX = midX + offsetX;\n    const controlY = midY + offsetY;\n    const pathData = `M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;\n    const uniqueId = `line-${nodeFrom}-${nodeTo}`;\n    let defs = group.select(\"defs\");\n    if (defs.empty()) {\n      defs = group.append(\"defs\");\n    }\n    defs.append(\"marker\").attr(\"id\", `arrow-${nodeFrom}-${nodeTo}`).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 28).attr(\"refY\", 5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto-start-reverse\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\", \"black\");\n    return group.append(\"path\").attr(\"id\", uniqueId).attr(\"d\", pathData).attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\n  }\n  createLine(nodeFrom, nodeTo, svgGroup, start, end, strokeColor = \"black\", strokeWidth = 2, opacity = 1) {\n    const uniqueId = `line-${nodeFrom}-${nodeTo}`;\n    let defs = svgGroup.select(\"defs\");\n    if (defs.empty()) {\n      defs = svgGroup.append(\"defs\");\n    }\n    defs.append(\"marker\").attr(\"id\", `arrow-${nodeFrom}-${nodeTo}}`).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 28).attr(\"refY\", 5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto-start-reverse\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\", \"black\");\n    return svgGroup.append(\"line\").attr(\"id\", uniqueId).attr(\"x1\", start.x).attr(\"y1\", start.y).attr(\"x2\", end.x).attr(\"y2\", end.y).attr(\"stroke\", strokeColor).attr(\"stroke-width\", strokeWidth).style(\"opacity\", opacity).attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\n  }\n  createLabel(nodesGroup, position, txt) {\n    return nodesGroup.append(\"text\").attr(\"x\", position.x).attr(\"y\", position.y).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"black\").style(\"font-size\", \"20px\").text(txt);\n  }\n  createNode(nodesGroup, cx, cy, r = 20, className = \"node\", initialOpacity = 0, isFinalNode = false) {\n    // Create the main node circle\n    const mainCircle = nodesGroup.append(\"circle\").attr(\"cx\", cx).attr(\"cy\", cy).attr(\"r\", r).attr(\"class\", className).style(\"opacity\", initialOpacity);\n    let outerRing = undefined;\n\n    // If it's a final node, add a second circle with a larger radius\n    if (isFinalNode) {\n      const outerRadius = r + 5;\n      outerRing = nodesGroup.append(\"circle\").attr(\"cx\", cx).attr(\"cy\", cy).attr(\"r\", outerRadius).attr(\"class\", className + \" final-node-ring\").style(\"fill\", \"none\").style(\"stroke\", \"black\").style(\"stroke-width\", 2).style(\"opacity\", initialOpacity);\n    }\n\n    // Return an object containing both selections\n    return {\n      mainCircle,\n      outerRing\n    };\n  }\n  applyNodeTransition(mainCircle, outerRing,\n  // Accept the optional outer ring\n  position, duration = 1000) {\n    return new Promise(resolve => {\n      const mainCircleTransition = mainCircle.transition().duration(duration).attr(\"cx\", position.x).attr(\"cy\", position.y).style(\"opacity\", 1).attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"fill\", \"white\");\n\n      // If an outer ring exists, apply the same transition to it\n      if (outerRing) {\n        outerRing.transition().duration(duration).attr(\"cx\", position.x).attr(\"cy\", position.y).style(\"opacity\", 1);\n      }\n      mainCircleTransition.on(\"end\", () => resolve());\n    });\n  }\n  applyLabelTransition(label, position, duration = 1000) {\n    return new Promise(resolve => {\n      label.transition().duration(duration).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y).on(\"end\", () => resolve());\n    });\n  }\n\n  // Gets the position in a shaped form\n  getPosition(index, numberOfNodes, centerX, centerY, radius = 150) {\n    const angle = 2 * Math.PI * index / numberOfNodes;\n\n    // Calculate x and y coordinates using polar to Cartesian conversion\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return {\n      x: x + centerX,\n      y: y + centerY\n    };\n  }\n}","map":{"version":3,"names":["pathIdCounter","FAAddAllInstruction","constructor","graph","process","svg","nodeTransitions","labelTransitions","linesGroup","append","attr","layoutCenterX","layoutCenterY","nodesGroup","indexNodes","Map","index","total","get_nodes","size","forEach","node","value","pos","getPosition","is_starting_node","is_final_node","nodeSelections","createNode","x","y","label","createLabel","node_transition","applyNodeTransition","mainCircle","outerRing","label_transition","applyLabelTransition","set","push","startNodePos","vx","vy","magnitude","Math","sqrt","unitVx","unitVy","angleDegrees","angleRadians","PI","rotatedVx","cos","sin","rotatedVy","arrowLength","arrowStartX","arrowStartY","arrowEndX","arrowEndY","createLine","pointers","get_pointers","entry","get","currentNode","current_node_pos","weights","pointer","targetEntry","get_value","targetIndex","_","target_node_pos","nodeAngle","atan2","loopRadius","angleOffset","startAngleRad","endAngleRad","startX","startY","endX","endY","controlPointDistance","controlX","controlY","pathData","uniqueId","defs","select","empty","selfLoopPath","createLineLabel","hasMutualPointer","curvedPath","createCurvedLine","straightLine","Promise","all","group","lineOrPath","txts","isLine","SVGLineElement","createdLabels","txt","text","style","line","x1","parseFloat","y1","x2","y2","midX","midY","dx","dy","lineLength","offsetX","offsetY","labelSpacing","totalOffset","length","path","pathId","startOffset","from","to","fromPointers","toPointers","fromPointsTo","Array","keys","some","p","toPointsTo","nodeFrom","nodeTo","curvature","norm","svgGroup","start","end","strokeColor","strokeWidth","opacity","position","cx","cy","r","className","initialOpacity","isFinalNode","undefined","outerRadius","duration","resolve","mainCircleTransition","transition","on","numberOfNodes","centerX","centerY","radius","angle"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_all_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\nimport {FA_Node} from \"../structures/fa_node\";\r\n\r\n// Counter to generate unique IDs for curved paths\r\nlet pathIdCounter = 0;\r\n\r\nexport class FAAddAllInstruction implements Instruction {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    constructor(graph: FA_Graph) {\r\n        this.graph = graph;\r\n        pathIdCounter = 0\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n        const nodeTransitions: Promise<void>[] = [];\r\n        const labelTransitions: Promise<void>[] = [];\r\n        const linesGroup = svg.append(\"g\").attr(\"id\", \"lines\") as unknown as d3.Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        const layoutCenterX = 350;\r\n        const layoutCenterY = 200;\r\n\r\n        const nodesGroup = (svg.append(\"g\") as unknown) as Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        let indexNodes: Map<string | number, [number, d3.Selection<SVGCircleElement, unknown, null, undefined>]> = new Map();\r\n        let index = 0;\r\n        const total = this.graph.get_nodes().size;\r\n\r\n        // Draw all nodes\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            const pos = this.getPosition(index, total, layoutCenterX, layoutCenterY);\r\n            const is_starting_node = this.graph.is_starting_node(value);\r\n            const is_final_node = this.graph.is_final_node(value); // Get the final node status\r\n\r\n            // Create the node(s) and get the selections\r\n            const nodeSelections = this.createNode(nodesGroup, pos.x, pos.y, 20, \"node\", 0, is_final_node);\r\n\r\n            const label = this.createLabel(nodesGroup, pos, value as string)\r\n\r\n            // Apply transition to both the main circle and the outer ring\r\n            const node_transition = this.applyNodeTransition(nodeSelections.mainCircle, nodeSelections.outerRing, pos);\r\n            const label_transition = this.applyLabelTransition(label, pos);\r\n\r\n            indexNodes.set(value, [index++, nodeSelections.mainCircle]);\r\n            nodeTransitions.push(node_transition);\r\n            labelTransitions.push(label_transition);\r\n\r\n            // If node is a starting state, add a line to it pointing away from the center\r\n            if (is_starting_node) {\r\n                const startNodePos = pos;\r\n\r\n                // Vector from layout center to starting node\r\n                const vx = startNodePos.x - layoutCenterX;\r\n                const vy = startNodePos.y - layoutCenterY;\r\n\r\n                // Normalize the vector\r\n                const magnitude = Math.sqrt(vx * vx + vy * vy);\r\n                let unitVx = magnitude === 0 ? 0 : vx / magnitude;\r\n                let unitVy = magnitude === 0 ? 0 : vy / magnitude;\r\n\r\n                const angleDegrees = 80;\r\n                const angleRadians = angleDegrees * (Math.PI / 180);\r\n\r\n                const rotatedVx = unitVx * Math.cos(angleRadians) - unitVy * Math.sin(angleRadians);\r\n                const rotatedVy = unitVx * Math.sin(angleRadians) + unitVy * Math.cos(angleRadians);\r\n\r\n                const arrowLength = 50;\r\n\r\n                // Arrow start (offset from the node in rotated direction)\r\n                const arrowStartX = startNodePos.x + rotatedVx * arrowLength;\r\n                const arrowStartY = startNodePos.y + rotatedVy * arrowLength;\r\n\r\n                // Arrow end at the node\r\n                const arrowEndX = startNodePos.x;\r\n                const arrowEndY = startNodePos.y;\r\n\r\n                this.createLine(value as string, \"\", linesGroup, { x: arrowStartX, y: arrowStartY }, { x: arrowEndX, y: arrowEndY });\r\n            }\r\n\r\n        });\r\n\r\n        // Draw connectors\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n\r\n            let pointers = this.graph.get_pointers(value);\r\n\r\n            if (pointers != null && pointers.size > 0) {\r\n\r\n                const entry = indexNodes.get(value);\r\n                if (!entry) return; // safety check\r\n\r\n                const [index, currentNode] = entry;\r\n                const current_node_pos = this.getPosition(index, total, 350, 200);\r\n\r\n                pointers.forEach((weights, pointer) => {\r\n                    const targetEntry = indexNodes.get(pointer.get_value());\r\n                    if (!targetEntry) return;\r\n\r\n                    const [targetIndex, _] = targetEntry;\r\n                    const target_node_pos = this.getPosition(targetIndex, total, 350, 200);\r\n\r\n                    // Loop arrow back to self - if value and pointer are equal\r\n                    if (value == pointer.get_value()) {\r\n                        // Calculate angle of the node from the layout center\r\n                        const nodeAngle = Math.atan2(current_node_pos.y - layoutCenterY, current_node_pos.x - layoutCenterX);\r\n\r\n                        const loopRadius = 40;\r\n                        const angleOffset = Math.PI / 6;\r\n\r\n                        let startAngleRad, endAngleRad;\r\n\r\n                        startAngleRad = nodeAngle - angleOffset;\r\n                        endAngleRad = nodeAngle + angleOffset;\r\n\r\n                        // Calculate start and end points on the node's circumference\r\n                        const startX = current_node_pos.x + 20 * Math.cos(startAngleRad);\r\n                        const startY = current_node_pos.y + 20 * Math.sin(startAngleRad);\r\n                        const endX = current_node_pos.x + 20 * Math.cos(endAngleRad);\r\n                        const endY = current_node_pos.y + 20 * Math.sin(endAngleRad);\r\n\r\n                        // Calculate control point for the arc\r\n                        // Position the control point further out along the radial direction\r\n                        const controlPointDistance = 20 + loopRadius * 2;\r\n                        const controlX = current_node_pos.x + controlPointDistance * Math.cos(nodeAngle);\r\n                        const controlY = current_node_pos.y + controlPointDistance * Math.sin(nodeAngle);\r\n\r\n                        // SVG path data for a self-loop using a quadratic bezier curve (Q)\r\n                        const pathData = `M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;\r\n\r\n                        const uniqueId = `line-${value as string}-${pointer.get_value() as string}`;\r\n\r\n                        let defs = linesGroup.select<SVGDefsElement>(\"defs\");\r\n                        if (defs.empty()) {\r\n                            defs = linesGroup.append<SVGDefsElement>(\"defs\");\r\n                        }\r\n                        defs.append(\"marker\")\r\n                            .attr(\"id\", `arrow-${value as string}-${pointer.get_value() as string}`)\r\n                            .attr(\"viewBox\", \"0 0 10 10\")\r\n                            .attr(\"refX\", 28)\r\n                            .attr(\"refY\", 5)\r\n                            .attr(\"markerWidth\", 6)\r\n                            .attr(\"markerHeight\", 6)\r\n                            .attr(\"orient\", \"auto-start-reverse\")\r\n                            .append(\"path\")\r\n                            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n                            .attr(\"fill\", \"black\");\r\n\r\n                        const selfLoopPath = linesGroup.append(\"path\")\r\n                            .attr(\"id\", uniqueId)\r\n                            .attr(\"d\", pathData)\r\n                            .attr(\"fill\", \"none\")\r\n                            .attr(\"stroke\", \"black\")\r\n                            .attr(\"stroke-width\", 2)\r\n                            .attr(\"marker-end\", `url(#arrow-${value as string}-${pointer.get_value() as string})`);\r\n\r\n                        // Create label for the self-loop\r\n                        this.createLineLabel(linesGroup, selfLoopPath, weights as string[]);\r\n                    }\r\n                    else if (this.hasMutualPointer(value, pointer.get_value())){\r\n                        const curvedPath = this.createCurvedLine(value as string, pointer.get_value() as string, linesGroup, current_node_pos, target_node_pos, 0.12);\r\n                        this.createLineLabel(linesGroup, curvedPath, weights as string[]);\r\n                    }\r\n                    else\r\n                    {\r\n                        const straightLine = this.createLine(value as string, pointer.get_value() as string, linesGroup, current_node_pos, target_node_pos);\r\n                        this.createLineLabel(linesGroup, straightLine as d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>, weights as string[]);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        await Promise.all([...nodeTransitions, ...labelTransitions]);\r\n    }\r\n\r\n    // Creates a label for a line (edge) {Mostly generated through gpt and gemini -- edited by michael}\r\n    createLineLabel(\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        lineOrPath: d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>,\r\n        txts: string[]\r\n    ): d3.Selection<SVGTextElement, unknown, null, undefined>[] {\r\n\r\n        const isLine = lineOrPath.node() instanceof SVGLineElement;\r\n        const createdLabels: d3.Selection<SVGTextElement, unknown, null, undefined>[] = [];\r\n\r\n        txts.forEach((txt, index) => {\r\n            // Append a text element for each weight\r\n            const text = group.append(\"text\")\r\n                .style(\"fill\", \"red\")\r\n                .style(\"font-size\", \"16px\")\r\n                .style(\"pointer-events\", \"none\");\r\n\r\n            if (isLine) {\r\n                const line = lineOrPath as d3.Selection<SVGLineElement, unknown, null, undefined>;\r\n                const x1 = parseFloat(line.attr(\"x1\"));\r\n                const y1 = parseFloat(line.attr(\"y1\"));\r\n                const x2 = parseFloat(line.attr(\"x2\"));\r\n                const y2 = parseFloat(line.attr(\"y2\"));\r\n\r\n                // Calculate midpoint\r\n                const midX = (x1 + x2) / 2;\r\n                const midY = (y1 + y2) / 2 - 10;\r\n\r\n                // Calculate perpendicular offset\r\n                const dx = x2 - x1;\r\n                const dy = y2 - y1;\r\n                const lineLength = Math.sqrt(dx * dx + dy * dy);\r\n                // Add a small check for zero length to avoid division by zero\r\n                const offsetX = lineLength === 0 ? 0 : (-dy / lineLength);\r\n                const offsetY = lineLength === 0 ? 0 : (-dx / lineLength);\r\n\r\n                // Adjust position based on the index for multiple labels\r\n                const labelSpacing = 15; // Adjust this value for desired spacing\r\n                const totalOffset = (index - (txts.length - 1) / 2) * labelSpacing; // Center the labels around the midpoint\r\n\r\n                text.attr(\"x\", midX + offsetX * totalOffset)\r\n                    .attr(\"y\", midY + offsetY * totalOffset)\r\n                    .attr(\"text-anchor\", \"middle\")\r\n                    .attr(\"alignment-baseline\", \"middle\")\r\n                    .text(txt);\r\n\r\n            } else {\r\n                const path = lineOrPath as d3.Selection<SVGPathElement, unknown, null, undefined>;\r\n                const pathId = path.attr(\"id\");\r\n\r\n                // Adjust startOffset for each label along the curve\r\n                const startOffset = (80 - (txts.length - 1) * 2) + ((index - (txts.length - 1) / 2) * 5);\r\n\r\n                text.append(\"textPath\")\r\n                    .attr(\"xlink:href\", `#${pathId}`)\r\n                    .attr(\"startOffset\", `${startOffset}%`)\r\n                    .attr(\"text-anchor\", \"middle\")\r\n                    .text(txt);\r\n            }\r\n            createdLabels.push(text);\r\n        });\r\n\r\n        return createdLabels;\r\n    }\r\n\r\n    hasMutualPointer(from: string | number, to: string | number): boolean {\r\n        const fromPointers = this.graph.get_pointers(from);\r\n        const toPointers = this.graph.get_pointers(to);\r\n\r\n        if (!fromPointers || !toPointers) return false;\r\n\r\n        // Compare the node values (not the FA_Node instances)\r\n        const fromPointsTo = Array.from(fromPointers.keys()).some(p => p.get_value() === to);\r\n        const toPointsTo = Array.from(toPointers.keys()).some(p => p.get_value() === from);\r\n\r\n        return fromPointsTo && toPointsTo;\r\n    }\r\n\r\n\r\n    createCurvedLine(\r\n        nodeFrom: string,\r\n        nodeTo: string,\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        from: { x: number, y: number },\r\n        to: { x: number, y: number },\r\n        curvature: number = 0.3\r\n    ): d3.Selection<SVGPathElement, unknown, null, undefined> {\r\n\r\n        // Midpoint between from and to\r\n        const midX = (from.x + to.x) / 2;\r\n        const midY = (from.y + to.y) / 2;\r\n\r\n        // Offset for the curve (perpendicular to the line)\r\n        const dx = to.x - from.x;\r\n        const dy = to.y - from.y;\r\n        const norm = Math.sqrt(dx * dx + dy * dy);\r\n        const offsetX = -dy * curvature;\r\n        const offsetY = dx * curvature;\r\n\r\n        const controlX = midX + offsetX;\r\n        const controlY = midY + offsetY;\r\n\r\n        const pathData = `M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;\r\n\r\n        const uniqueId = `line-${nodeFrom}-${nodeTo}`;\r\n\r\n        let defs = group.select<SVGDefsElement>(\"defs\");\r\n        if (defs.empty()) {\r\n            defs = group.append<SVGDefsElement>(\"defs\");\r\n        }\r\n\r\n        defs.append(\"marker\")\r\n            .attr(\"id\", `arrow-${nodeFrom}-${nodeTo}`)\r\n            .attr(\"viewBox\", \"0 0 10 10\")\r\n            .attr(\"refX\", 28)\r\n            .attr(\"refY\", 5)\r\n            .attr(\"markerWidth\", 6)\r\n            .attr(\"markerHeight\", 6)\r\n            .attr(\"orient\", \"auto-start-reverse\")\r\n            .append(\"path\")\r\n            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n            .attr(\"fill\", \"black\");\r\n\r\n        return group.append(\"path\")\r\n            .attr(\"id\", uniqueId)\r\n            .attr(\"d\", pathData)\r\n            .attr(\"fill\", \"none\")\r\n            .attr(\"stroke\", \"black\")\r\n            .attr(\"stroke-width\", 2)\r\n            .attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\r\n    }\r\n\r\n    createLine(\r\n        nodeFrom: String,\r\n        nodeTo: String,\r\n        svgGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        start: { x: number; y: number },\r\n        end: { x: number; y: number },\r\n        strokeColor: string = \"black\",\r\n        strokeWidth: number = 2,\r\n        opacity: number = 1\r\n    ): d3.Selection<SVGLineElement, unknown, null, undefined> {\r\n        const uniqueId = `line-${nodeFrom}-${nodeTo}`;\r\n\r\n        let defs = svgGroup.select<SVGDefsElement>(\"defs\");\r\n        if (defs.empty()) {\r\n            defs = svgGroup.append<SVGDefsElement>(\"defs\");\r\n        }\r\n\r\n        defs.append(\"marker\")\r\n            .attr(\"id\", `arrow-${nodeFrom}-${nodeTo}}`)\r\n            .attr(\"viewBox\", \"0 0 10 10\")\r\n            .attr(\"refX\", 28)\r\n            .attr(\"refY\", 5)\r\n            .attr(\"markerWidth\", 6)\r\n            .attr(\"markerHeight\", 6)\r\n            .attr(\"orient\", \"auto-start-reverse\")\r\n            .append(\"path\")\r\n            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n            .attr(\"fill\", \"black\");\r\n\r\n        return svgGroup.append(\"line\")\r\n            .attr(\"id\", uniqueId)\r\n            .attr(\"x1\", start.x)\r\n            .attr(\"y1\", start.y)\r\n            .attr(\"x2\", end.x)\r\n            .attr(\"y2\", end.y)\r\n            .attr(\"stroke\", strokeColor)\r\n            .attr(\"stroke-width\", strokeWidth)\r\n            .style(\"opacity\", opacity)\r\n            .attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\r\n    }\r\n\r\n\r\n    createLabel(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, position: { x: number, y: number }, txt: string): d3.Selection<SVGTextElement, unknown, null, undefined> {\r\n        return nodesGroup.append(\"text\")\r\n            .attr(\"x\", position.x)\r\n            .attr(\"y\", position.y)\r\n            .attr(\"class\", \"label\")\r\n            .attr(\"text-anchor\", \"middle\")\r\n            .attr(\"alignment-baseline\", \"middle\")\r\n            .style(\"fill\", \"black\")\r\n            .style(\"font-size\", \"20px\")\r\n            .text(txt);\r\n    }\r\n\r\n\r\n    createNode(\r\n        nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        cx: number,\r\n        cy: number,\r\n        r: number = 20,\r\n        className: string = \"node\",\r\n        initialOpacity: number = 0,\r\n        isFinalNode: boolean = false\r\n    ): { mainCircle: d3.Selection<SVGCircleElement, unknown, null, undefined>, outerRing?: d3.Selection<SVGCircleElement, unknown, null, undefined> } {\r\n\r\n        // Create the main node circle\r\n        const mainCircle = nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", cx)\r\n            .attr(\"cy\", cy)\r\n            .attr(\"r\", r)\r\n            .attr(\"class\", className)\r\n            .style(\"opacity\", initialOpacity);\r\n\r\n        let outerRing: d3.Selection<SVGCircleElement, unknown, null, undefined> | undefined = undefined;\r\n\r\n        // If it's a final node, add a second circle with a larger radius\r\n        if (isFinalNode) {\r\n            const outerRadius = r + 5;\r\n            outerRing = nodesGroup.append(\"circle\")\r\n                .attr(\"cx\", cx)\r\n                .attr(\"cy\", cy)\r\n                .attr(\"r\", outerRadius)\r\n                .attr(\"class\", className + \" final-node-ring\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\", \"black\")\r\n                .style(\"stroke-width\", 2)\r\n                .style(\"opacity\", initialOpacity);\r\n        }\r\n\r\n        // Return an object containing both selections\r\n        return { mainCircle, outerRing };\r\n    }\r\n\r\n    applyNodeTransition(\r\n        mainCircle: d3.Selection<SVGCircleElement, unknown, null, undefined>,\r\n        outerRing: d3.Selection<SVGCircleElement, unknown, null, undefined> | undefined, // Accept the optional outer ring\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n\r\n            const mainCircleTransition = mainCircle.transition()\r\n                .duration(duration)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"white\");\r\n\r\n            // If an outer ring exists, apply the same transition to it\r\n            if (outerRing) {\r\n                outerRing.transition()\r\n                    .duration(duration)\r\n                    .attr(\"cx\", position.x)\r\n                    .attr(\"cy\", position.y)\r\n                    .style(\"opacity\", 1);\r\n            }\r\n\r\n            mainCircleTransition.on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n    applyLabelTransition(\r\n        label: d3.Selection<SVGTextElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            label.transition()\r\n                .duration(duration)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y)\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n\r\n    // Gets the position in a shaped form\r\n    getPosition(index: number, numberOfNodes: number, centerX: number, centerY: number, radius: number = 150) {\r\n        const angle = (2 * Math.PI * index) / numberOfNodes;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}