{"ast":null,"code":"export class FAAddAllInstruction {\n  constructor(graph) {\n    this.graph = void 0;\n    this.graph = graph;\n  }\n  async process(svg) {\n    let nodeTransitions = [];\n    const nodesGroup = svg.append(\"g\").attr(\"id\", \"nodes\");\n    let index = 0;\n    this.graph.get_nodes().forEach((node, value) => {\n      const pos = this.getPosition(index++, total, 350, 200);\n      const createdNode = this.createNode(nodesGroup, 0, 0); // Start at 0,0 if transitioning\n      const transition = this.applyNodeTransition(createdNode, pos); // Returns a promise\n      nodeTransitions.push(transition);\n    });\n    return Promise.all([nodeTransitions]);\n  }\n  createNode(nodesGroup, cx, cy, r = 20, className = \"node\", opacity = 0) {\n    return nodesGroup.append(\"circle\").attr(\"cx\", cx).attr(\"cy\", cy).attr(\"r\", r).attr(\"class\", className).style(\"opacity\", opacity);\n  }\n  applyNodeTransition(node, position, duration = 1000) {\n    return node.transition().duration(duration).style(\"opacity\", 1).attr(\"cx\", position.x).attr(\"cy\", position.y).attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"fill\", \"white\");\n  }\n\n  // Gets the position in a shaped form\n  getPosition(index, numberOfNodes, centerX, centerY, radius = 100) {\n    const angle = 2 * Math.PI * index / numberOfNodes;\n\n    // Calculate x and y coordinates using polar to Cartesian conversion\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return {\n      x: x + centerX,\n      y: y + centerY\n    };\n  }\n}","map":{"version":3,"names":["FAAddAllInstruction","constructor","graph","process","svg","nodeTransitions","nodesGroup","append","attr","index","get_nodes","forEach","node","value","pos","getPosition","total","createdNode","createNode","transition","applyNodeTransition","push","Promise","all","cx","cy","r","className","opacity","style","position","duration","x","y","numberOfNodes","centerX","centerY","radius","angle","Math","PI","cos","sin"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_all_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\n\r\nexport class FAAddAllInstruction implements Instruction {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    constructor(graph: FA_Graph) {\r\n        this.graph = graph;\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n\r\n        let nodeTransitions : Promise<void>[] = [];\r\n        const nodesGroup = svg.append(\"g\").attr(\"id\", \"nodes\");\r\n\r\n        let index = 0;\r\n        \r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            const pos = this.getPosition(index++, total, 350, 200);\r\n            const createdNode = this.createNode(nodesGroup, 0, 0); // Start at 0,0 if transitioning\r\n            const transition = this.applyNodeTransition(createdNode, pos); // Returns a promise\r\n            nodeTransitions.push(transition);\r\n        });\r\n\r\n\r\n\r\n\r\n        return Promise.all([nodeTransitions]);\r\n    }\r\n\r\n    createNode(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, cx: number, cy: number, r: number = 20,\r\n                                        className: string = \"node\", opacity: number = 0\r\n    ): d3.Selection<SVGCircleElement, unknown, null, undefined> {\r\n\r\n        return nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", cx)\r\n            .attr(\"cy\", cy)\r\n            .attr(\"r\", r)\r\n            .attr(\"class\", className)\r\n            .style(\"opacity\", opacity);\r\n    }\r\n\r\n    applyNodeTransition(\r\n        node: d3.Selection<SVGCircleElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): d3.Transition<SVGCircleElement, unknown, null, undefined> {\r\n\r\n        return node.transition()\r\n            .duration(duration)\r\n            .style(\"opacity\", 1)\r\n            .attr(\"cx\", position.x)\r\n            .attr(\"cy\", position.y)\r\n            .attr(\"stroke\", \"black\")\r\n            .attr(\"stroke-width\", 2)\r\n            .attr(\"fill\", \"white\");\r\n    }\r\n\r\n\r\n\r\n    // Gets the position in a shaped form\r\n    getPosition(index: number, numberOfNodes: number, centerX: number, centerY: number, radius: number = 100) {\r\n        const angle = (2 * Math.PI * index) / numberOfNodes;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"AAIA,OAAO,MAAMA,mBAAmB,CAAwB;EAIpDC,WAAWA,CAACC,KAAe,EAAE;IAAA,KAFrBA,KAAK;IAGT,IAAI,CAACA,KAAK,GAAGA,KAAK;EACtB;EAEA,MAAMC,OAAOA,CAACC,GAAmD,EAAiB;IAE9E,IAAIC,eAAiC,GAAG,EAAE;IAC1C,MAAMC,UAAU,GAAGF,GAAG,CAACG,MAAM,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC;IAEtD,IAAIC,KAAK,GAAG,CAAC;IAEb,IAAI,CAACP,KAAK,CAACQ,SAAS,CAAC,CAAC,CAACC,OAAO,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK;MAC5C,MAAMC,GAAG,GAAG,IAAI,CAACC,WAAW,CAACN,KAAK,EAAE,EAAEO,KAAK,EAAE,GAAG,EAAE,GAAG,CAAC;MACtD,MAAMC,WAAW,GAAG,IAAI,CAACC,UAAU,CAACZ,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;MACvD,MAAMa,UAAU,GAAG,IAAI,CAACC,mBAAmB,CAACH,WAAW,EAAEH,GAAG,CAAC,CAAC,CAAC;MAC/DT,eAAe,CAACgB,IAAI,CAACF,UAAU,CAAC;IACpC,CAAC,CAAC;IAKF,OAAOG,OAAO,CAACC,GAAG,CAAC,CAAClB,eAAe,CAAC,CAAC;EACzC;EAEAa,UAAUA,CAACZ,UAA+D,EAAEkB,EAAU,EAAEC,EAAU,EAAEC,CAAS,GAAG,EAAE,EAC9EC,SAAiB,GAAG,MAAM,EAAEC,OAAe,GAAG,CAAC,EACvB;IAExD,OAAOtB,UAAU,CAACC,MAAM,CAAC,QAAQ,CAAC,CAC7BC,IAAI,CAAC,IAAI,EAAEgB,EAAE,CAAC,CACdhB,IAAI,CAAC,IAAI,EAAEiB,EAAE,CAAC,CACdjB,IAAI,CAAC,GAAG,EAAEkB,CAAC,CAAC,CACZlB,IAAI,CAAC,OAAO,EAAEmB,SAAS,CAAC,CACxBE,KAAK,CAAC,SAAS,EAAED,OAAO,CAAC;EAClC;EAEAR,mBAAmBA,CACfR,IAA8D,EAC9DkB,QAAkC,EAClCC,QAAgB,GAAG,IAAI,EACkC;IAEzD,OAAOnB,IAAI,CAACO,UAAU,CAAC,CAAC,CACnBY,QAAQ,CAACA,QAAQ,CAAC,CAClBF,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC,CACnBrB,IAAI,CAAC,IAAI,EAAEsB,QAAQ,CAACE,CAAC,CAAC,CACtBxB,IAAI,CAAC,IAAI,EAAEsB,QAAQ,CAACG,CAAC,CAAC,CACtBzB,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CACvBA,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,CACvBA,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC;EAC9B;;EAIA;EACAO,WAAWA,CAACN,KAAa,EAAEyB,aAAqB,EAAEC,OAAe,EAAEC,OAAe,EAAEC,MAAc,GAAG,GAAG,EAAE;IACtG,MAAMC,KAAK,GAAI,CAAC,GAAGC,IAAI,CAACC,EAAE,GAAG/B,KAAK,GAAIyB,aAAa;;IAEnD;IACA,MAAMF,CAAC,GAAGK,MAAM,GAAGE,IAAI,CAACE,GAAG,CAACH,KAAK,CAAC;IAClC,MAAML,CAAC,GAAGI,MAAM,GAAGE,IAAI,CAACG,GAAG,CAACJ,KAAK,CAAC;IAElC,OAAO;MAAEN,CAAC,EAAEA,CAAC,GAAGG,OAAO;MAAEF,CAAC,EAAEA,CAAC,GAAGG;IAAQ,CAAC;EAC7C;AAEJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}