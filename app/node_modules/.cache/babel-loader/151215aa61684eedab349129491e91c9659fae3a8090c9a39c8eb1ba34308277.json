{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nimport * as d3 from \"d3\";\nexport const TreeAnimator = ({\n  instructions\n}) => {\n  _s();\n  const [instructionStack, setInstructionStack] = useState([]);\n  const nodes = [];\n  useEffect(() => {\n    const newInstructions = [{\n      type: 'add',\n      value: '1',\n      index: 0\n    }, {\n      type: 'add',\n      value: '2',\n      index: 1\n    }, {\n      type: 'add',\n      value: '3',\n      index: 2\n    }, {\n      type: 'add',\n      value: '4',\n      index: 3\n    }, {\n      type: 'add',\n      value: '5',\n      index: 4\n    }, {\n      type: 'add',\n      value: '6',\n      index: 5\n    }, {\n      type: 'swap',\n      fromIndex: 0,\n      toIndex: 1\n    }];\n    setInstructionStack(newInstructions);\n  }, []);\n  const processInstructions = async svg => {\n    for (let instruction of instructionStack) {\n      if (instruction.type === 'add' && instruction.value) {\n        // Wait for the previous node to finish its animation before adding the next one\n        await addNode(svg, instruction);\n      }\n      if (instruction.type === 'swap') {\n        await swapNodes(svg, nodes[instruction.toIndex], nodes[instruction.fromIndex]);\n        const i = nodes[instruction.toIndex].index;\n        nodes[instruction.toIndex].index = nodes[instruction.fromIndex].index;\n        nodes[instruction.fromIndex].index = i;\n      }\n    }\n  };\n  const getNodePosition = index => {\n    if (index < 0 || isNaN(index)) return {\n      x: 0,\n      y: 0\n    };\n    if (index === 0) return {\n      x: 250,\n      y: 50\n    }; // Root at the center\n\n    const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\n    const xSpacing = 200 / (depth + 1); // Adjust x spacing\n    const ySpacing = 80; // Vertical spacing\n\n    const parentIndex = Math.floor((index - 1) / 2);\n    const parentPos = getNodePosition(parentIndex);\n    const isLeftChild = index % 2 === 1;\n    const xOffset = isLeftChild ? -xSpacing : xSpacing;\n    return {\n      x: parentPos.x + xOffset,\n      y: parentPos.y + ySpacing\n    };\n  };\n\n  // Node function that appends a circle and returns the D3 selection\n  const addNode = (svg, instruction) => {\n    return new Promise(resolve => {\n      const nodeElement = svg.append(\"circle\").attr(\"cx\", 200) // Set starting x position\n      .attr(\"cy\", 200) // Set starting y position\n      .attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0); // Start with invisible node\n\n      const label = svg.append(\"text\").attr(\"x\", 200) // Same x position as the circle\n      .attr(\"y\", 200) // Same y position as the circle\n      .attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\") // Center the text horizontally\n      .attr(\"alignment-baseline\", \"middle\") // Center the text vertically\n      .style(\"fill\", \"white\") // Set text color\n      .style(\"font-size\", \"12px\").text(instruction.value);\n      const newNode = {\n        node: nodeElement,\n        label: label,\n        index: instruction.index\n      };\n      nodes.push(newNode);\n\n      // Animate the node: fade in and move\n      nodeElement.transition().duration(1000) // Duration of 1 second\n      .style(\"opacity\", 1) // Fade in the node\n      .attr(\"cx\", getNodePosition(instruction.index).x).attr(\"cy\", getNodePosition(instruction.index).y); // Keep y position constant for simplicity\n\n      label.transition().duration(1000) // Duration of 1 second (same as node)\n      .style(\"opacity\", 1).attr(\"x\", getNodePosition(instruction.index).x).attr(\"y\", getNodePosition(instruction.index).y);\n\n      // Resolve the promise after the animation duration\n      setTimeout(() => resolve(), 1000); // Wait for the animation to finish (1000ms)\n    });\n  };\n  const swapNodes = (svg, nodeA, nodeB) => {\n    //alert(nodes.length);\n\n    return new Promise(resolve => {\n      const node1 = nodeA.node;\n      const label1 = nodeA.label;\n      const node2 = nodeB.node;\n      const label2 = nodeB.label;\n      const node1Position = {\n        x: parseFloat(node1.attr(\"cx\")),\n        y: parseFloat(node1.attr(\"cy\"))\n      };\n      const node2Position = {\n        x: parseFloat(node2.attr(\"cx\")),\n        y: parseFloat(node2.attr(\"cy\"))\n      };\n\n      // Animate node1 to node2's position\n      node1.transition().duration(1000).attr(\"cx\", node2Position.x).attr(\"cy\", node2Position.y);\n\n      // Animate label1 to node2's position\n      label1.transition().duration(1000).attr(\"x\", node2Position.x).attr(\"y\", node2Position.y);\n\n      // Animate node2 to node1's position\n      node2.transition().duration(1000).attr(\"cx\", node1Position.x).attr(\"cy\", node1Position.y);\n\n      // Animate label2 to node1's position\n      label2.transition().duration(1000).attr(\"x\", node1Position.x).attr(\"y\", node1Position.y);\n      setTimeout(() => resolve(), 1000);\n    });\n  };\n  useEffect(() => {\n    // Select the SVG element that the D3 code will operate on\n    const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\n\n    // Process the instructions to add nodes\n    processInstructions(svg);\n  }, [instructionStack]); // Empty dependency array to run the effect only once\n\n  return null; // No need to return an element here, as we're using D3 to manipulate the SVG\n};\n_s(TreeAnimator, \"TFYHpKeMWd12HTpksPsVMW+UKFk=\");\n_c = TreeAnimator;\nvar _c;\n$RefreshReg$(_c, \"TreeAnimator\");","map":{"version":3,"names":["useEffect","useState","d3","TreeAnimator","instructions","_s","instructionStack","setInstructionStack","nodes","newInstructions","type","value","index","fromIndex","toIndex","processInstructions","svg","instruction","addNode","swapNodes","i","getNodePosition","isNaN","x","y","depth","Math","floor","log2","xSpacing","ySpacing","parentIndex","parentPos","isLeftChild","xOffset","Promise","resolve","nodeElement","append","attr","style","label","text","newNode","node","push","transition","duration","setTimeout","nodeA","nodeB","node1","label1","node2","label2","node1Position","parseFloat","node2Position","select","_c","$RefreshReg$"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/animation_testing.tsx"],"sourcesContent":["import React, {useEffect, useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {BaseType} from \"d3\";\r\nimport {Instruction} from \"./tree_intructions\";\r\n\r\ninterface TreeAnimatorProps {\r\n    instructions: Instruction[];\r\n}\r\n\r\nexport const TreeAnimator: React.FC<TreeAnimatorProps> = ({ instructions }) => {\r\n\r\n    const [instructionStack, setInstructionStack] = useState<Instruction[]>([]);\r\n\r\n    const nodes: NodeData[] = [];\r\n\r\n    type NodeData = {\r\n        node: d3.Selection<SVGCircleElement, unknown, HTMLElement, any>;\r\n        label: d3.Selection<SVGTextElement, unknown, HTMLElement, any>;\r\n        index: number;\r\n    };\r\n\r\n\r\n    useEffect(() => {\r\n        const newInstructions: Instruction[] = [\r\n            { type: 'add', value: '1', index: 0 },\r\n            { type: 'add', value: '2', index: 1 },\r\n            { type: 'add', value: '3', index: 2 },\r\n            { type: 'add', value: '4', index: 3 },\r\n            { type: 'add', value: '5', index: 4 },\r\n            { type: 'add', value: '6', index: 5 },\r\n            { type: 'swap', fromIndex: 0, toIndex: 1 },\r\n        ];\r\n        setInstructionStack(newInstructions);\r\n    }, []);\r\n\r\n    const processInstructions = async (svg: d3.Selection<BaseType, unknown, HTMLElement, any>) => {\r\n        for (let instruction of instructionStack) {\r\n            if (instruction.type === 'add' && instruction.value) {\r\n                // Wait for the previous node to finish its animation before adding the next one\r\n                await addNode(svg, instruction);\r\n            }\r\n\r\n            if (instruction.type === 'swap') {\r\n                await swapNodes(svg, nodes[instruction.toIndex as number], nodes[instruction.fromIndex as number]);\r\n\r\n                const i = nodes[instruction.toIndex as number].index;\r\n                nodes[instruction.toIndex as number].index = nodes[instruction.fromIndex as number].index;\r\n                nodes[instruction.fromIndex as number].index = i;\r\n            }\r\n\r\n        }\r\n    };\r\n\r\n    const getNodePosition = (index: number): { x: number, y: number } => {\r\n        if (index < 0 || isNaN(index)) return { x: 0, y: 0 };\r\n        if (index === 0) return { x: 250, y: 50 }; // Root at the center\r\n\r\n        const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\r\n        const xSpacing = (200) / (depth + 1); // Adjust x spacing\r\n        const ySpacing = 80; // Vertical spacing\r\n\r\n        const parentIndex = Math.floor((index - 1) / 2);\r\n        const parentPos = getNodePosition(parentIndex);\r\n\r\n        const isLeftChild = index % 2 === 1;\r\n        const xOffset = isLeftChild ? -xSpacing : xSpacing;\r\n\r\n        return { x: parentPos.x + xOffset, y: parentPos.y + ySpacing };\r\n    };\r\n\r\n    // Node function that appends a circle and returns the D3 selection\r\n    const addNode = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>, instruction: Instruction) => {\r\n\r\n        return new Promise<void>((resolve) => {\r\n            const nodeElement = svg.append(\"circle\")\r\n                .attr(\"cx\", 200)  // Set starting x position\r\n                .attr(\"cy\", 200)  // Set starting y position\r\n                .attr(\"r\", 20)\r\n                .attr(\"class\", \"node\")\r\n                .style(\"opacity\", 0);  // Start with invisible node\r\n\r\n            const label = svg.append(\"text\")\r\n                .attr(\"x\", 200)  // Same x position as the circle\r\n                .attr(\"y\", 200)  // Same y position as the circle\r\n                .attr(\"class\", \"label\")\r\n                .attr(\"text-anchor\", \"middle\")  // Center the text horizontally\r\n                .attr(\"alignment-baseline\", \"middle\")  // Center the text vertically\r\n                .style(\"fill\", \"white\")  // Set text color\r\n                .style(\"font-size\", \"12px\")\r\n                .text(instruction.value as number | string);\r\n\r\n            const newNode: NodeData = {\r\n                node: nodeElement,\r\n                label: label,\r\n                index: instruction.index as number,\r\n            };\r\n\r\n            nodes.push(newNode);\r\n\r\n            // Animate the node: fade in and move\r\n            nodeElement.transition()\r\n                .duration(1000)  // Duration of 1 second\r\n                .style(\"opacity\", 1)  // Fade in the node\r\n                .attr(\"cx\", getNodePosition(instruction.index as number).x)\r\n                .attr(\"cy\", getNodePosition(instruction.index as number).y);  // Keep y position constant for simplicity\r\n\r\n            label.transition()\r\n                .duration(1000)  // Duration of 1 second (same as node)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", getNodePosition(instruction.index as number).x)\r\n                .attr(\"y\", getNodePosition(instruction.index as number).y);\r\n\r\n            // Resolve the promise after the animation duration\r\n            setTimeout(() => resolve(), 1000);  // Wait for the animation to finish (1000ms)\r\n        });\r\n    };\r\n\r\n    const swapNodes = (\r\n        svg: d3.Selection<BaseType, unknown, HTMLElement, any>,\r\n        nodeA: NodeData,\r\n        nodeB: NodeData,\r\n    ) => {\r\n\r\n        //alert(nodes.length);\r\n\r\n        return new Promise<void>((resolve) => {\r\n            const node1 = nodeA.node;\r\n            const label1 = nodeA.label;\r\n            const node2 = nodeB.node;\r\n            const label2 = nodeB.label;\r\n\r\n\r\n            const node1Position = { x: parseFloat(node1.attr(\"cx\")), y: parseFloat(node1.attr(\"cy\")) };\r\n            const node2Position = { x: parseFloat(node2.attr(\"cx\")), y: parseFloat(node2.attr(\"cy\")) };\r\n\r\n            // Animate node1 to node2's position\r\n            node1.transition()\r\n                .duration(1000)\r\n                .attr(\"cx\", node2Position.x)\r\n                .attr(\"cy\", node2Position.y);\r\n\r\n            // Animate label1 to node2's position\r\n            label1.transition()\r\n                .duration(1000)\r\n                .attr(\"x\", node2Position.x)\r\n                .attr(\"y\", node2Position.y);\r\n\r\n            // Animate node2 to node1's position\r\n            node2.transition()\r\n                .duration(1000)\r\n                .attr(\"cx\", node1Position.x)\r\n                .attr(\"cy\", node1Position.y);\r\n\r\n            // Animate label2 to node1's position\r\n            label2.transition()\r\n                .duration(1000)\r\n                .attr(\"x\", node1Position.x)\r\n                .attr(\"y\", node1Position.y);\r\n\r\n            setTimeout(() => resolve(), 1000);\r\n        });\r\n    };\r\n\r\n\r\n    useEffect(() => {\r\n        // Select the SVG element that the D3 code will operate on\r\n        const svg = d3.select(\"#svg-container\")\r\n            .attr(\"width\", 500)\r\n            .attr(\"height\", 500);\r\n\r\n        // Process the instructions to add nodes\r\n        processInstructions(svg);\r\n    }, [instructionStack]);   // Empty dependency array to run the effect only once\r\n\r\n    return null;  // No need to return an element here, as we're using D3 to manipulate the SVG\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}