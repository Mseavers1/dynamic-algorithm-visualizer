{"ast":null,"code":"import { FA_Graph } from \"../structures/fa_graph\";\nimport { FAAddAllInstruction } from \"../Instructions/fa_add_all_instruction\";\nimport * as d3 from \"d3\";\nimport { FAHighlightInstruction } from \"../Instructions/highlight_fa_node_instruction\";\nexport class FATransition {\n  constructor(animator) {\n    this.graph = void 0;\n    this.animator = void 0;\n    this.showClear = true;\n    this.showDelete = false;\n    this.showInsert = true;\n    this.showRandomize = false;\n    this.showSearch = false;\n    this.showField = true;\n    this.insert_name = \"Validate\";\n    this.graph = new FA_Graph();\n    this.animator = animator;\n  }\n  getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  /* generateNewColor(): Color {\r\n      let c: Color = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n        let exists = this.colorUsed.some(\r\n          (color) => color.r === c.r &&\r\n              color.g === c.g &&\r\n              color.b === c.b &&\r\n              color.a === c.a\r\n      );\r\n        let attemps = 0;\r\n        while (exists) {\r\n            if (attemps > 50) break;\r\n            c = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n            exists = this.colorUsed.some(\r\n              (color) => color.r === c.r &&\r\n                  color.g === c.g &&\r\n                  color.b === c.b &&\r\n                  color.a === c.a\r\n          );\r\n            attemps++;\r\n      }\r\n        this.colorUsed.push(c);\r\n        return c;\r\n  } */\n\n  parse(area) {\n    // Is code valid?\n    const lines = area.split(\"\\n\");\n    let valid = true;\n    let currentNodeValue = \"\";\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n\n      // Ignore comments\n      if (line.startsWith('#') || line.startsWith('//')) continue;\n\n      // If it doesn't start with a space, it is the start of a state definition\n      if (!line.startsWith(' ') && line.includes(':')) {\n        const value = line.split(\":\")[0];\n        if (this.graph.get_node(value) == null) this.graph.create_node(value);\n        currentNodeValue = value;\n      }\n\n      // If it does, it is a value in a state definition\n      else {\n        // Get rid of spaces\n        const new_line = line.replace(/\\s+/g, '');\n\n        // Check if there is a : - if so, its a value, if not, its either Start or Final keywords\n        if (new_line.includes(':')) {\n          const pointer = new_line.split(\":\")[0];\n          const weights = new_line.split(\":\")[1].split(\",\").map(w => w.trim());\n\n          //this.states[currentState].push({state: state, values: values});\n\n          if (this.graph.get_node(pointer) == null) this.graph.create_node(pointer);\n          this.graph.add_node_pointers(currentNodeValue, weights, pointer);\n        }\n        // Keywords\n        else {\n          // Set the starting state\n          if (new_line.toUpperCase() === \"START\") {\n            this.graph.set_starting_node(currentNodeValue);\n          }\n\n          // Add onto the final states\n          if (new_line.toUpperCase() === \"FINAL\") {\n            this.graph.add_final_node(currentNodeValue);\n          }\n        }\n      }\n    }\n\n    // Is there a starting state? If not, cause error\n    if (!this.graph.has_starting_node()) {\n      valid = false;\n    }\n\n    // Is there any final states? Is not, cause error\n    if (!this.graph.has_one_final_node()) {\n      valid = false;\n    }\n\n    // If valid, generate animation / structure\n    if (valid) {\n      this.animator.addInstruction(new FAAddAllInstruction(this.graph));\n\n      /*\r\n      let indexStates : Record<string, number> | null = {};\r\n      let colorStates : Record<string, Color> = {};\r\n        let index = 0;\r\n      for (const state in this.states) {\r\n            indexStates[state] = index;\r\n          colorStates[state] = this.generateNewColor();\r\n            //const stateArray = this.states[state];\r\n            //stateArray.forEach((value) => {\r\n          //    this.animator.addInstruction(new FAAddInstruction(index, value, ))\r\n          //});\r\n            let isStarting = state === this.startingState;\r\n          let isFinal = this.finalStates.includes(state);\r\n            this.animator.addInstruction(new FAAddInstruction(index, state, Object.keys(this.states).length, this.states[state], indexStates, colorStates, isStarting, isFinal));\r\n            index += 1;\r\n      } */\n\n      this.animator.processInstructions();\n    }\n  }\n  clear() {\n    this.graph = new FA_Graph();\n    const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\n    svg.selectAll(\"*\").remove();\n  }\n  delete(value) {}\n  generate_random(min, max, size, allowStrings, allowNumbers, allowDecimal, maxDecimal, regex, stringLengthMin, stringLengthMax) {}\n\n  // Check to see if value is in FA\n  insert(value) {\n    var _current_node;\n    // Start from the starting node\n    let current_node = this.graph.get_starting_node();\n    let prev_node = null;\n    this.animator.addInstruction(new FAHighlightInstruction((_current_node = current_node) === null || _current_node === void 0 ? void 0 : _current_node.get_value(), \"\"));\n\n    // Validate each letter until input crash\n    for (let letter of value.toString()) {\n      var _current_node2;\n      const pointers = (_current_node2 = current_node) === null || _current_node2 === void 0 ? void 0 : _current_node2.get_pointers();\n      if (!pointers) return;\n      let found = false;\n\n      // Search through pointers to see if weight matches\n      pointers.forEach((weights, node) => {\n        if (weights.includes(letter)) {\n          prev_node = current_node;\n          current_node = node;\n          found = true;\n        }\n      });\n\n      // If no matches, input crash\n      if (!found) {\n        alert(\"Input Crash\");\n        return;\n      } else {\n        // Highlight path\n        if (prev_node != null) {\n          var _current_node3;\n          this.animator.addInstruction(new FAHighlightInstruction((_current_node3 = current_node) === null || _current_node3 === void 0 ? void 0 : _current_node3.get_value(), prev_node.get_value()));\n        }\n      }\n    }\n\n    // Check to see if the last landed node is a final state (If not, input crash)\n    if (current_node == null || !this.graph.is_final_node(current_node.get_value())) {\n      alert(\"Input Crash\");\n      return;\n    }\n    this.animator.processInstructions();\n    alert(\"Yes, the string is in the machine!\");\n  }\n}","map":{"version":3,"names":["FA_Graph","FAAddAllInstruction","d3","FAHighlightInstruction","FATransition","constructor","animator","graph","showClear","showDelete","showInsert","showRandomize","showSearch","showField","insert_name","getRandomInt","min","max","Math","floor","random","parse","area","lines","split","valid","currentNodeValue","i","length","line","startsWith","includes","value","get_node","create_node","new_line","replace","pointer","weights","map","w","trim","add_node_pointers","toUpperCase","set_starting_node","add_final_node","has_starting_node","has_one_final_node","addInstruction","processInstructions","clear","svg","select","attr","selectAll","remove","delete","generate_random","size","allowStrings","allowNumbers","allowDecimal","maxDecimal","regex","stringLengthMin","stringLengthMax","insert","_current_node","current_node","get_starting_node","prev_node","get_value","letter","toString","_current_node2","pointers","get_pointers","found","forEach","node","alert","_current_node3","is_final_node"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/fa_transition.tsx"],"sourcesContent":["import {Algorithm} from \"./algorithm_interface\";\r\nimport {AnimationPlayer} from \"../animation_player\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\nimport {FAAddAllInstruction} from \"../Instructions/fa_add_all_instruction\";\r\nimport * as d3 from \"d3\";\r\nimport {FAHighlightInstruction} from \"../Instructions/highlight_fa_node_instruction\";\r\nimport {FA_Node} from \"../structures/fa_node\";\r\n\r\nexport type stateValues = {\r\n    state: string;\r\n    values: string[];\r\n}\r\n\r\nexport class FATransition implements Algorithm {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    private animator: AnimationPlayer;\r\n\r\n    public showClear: boolean = true;\r\n    public showDelete: boolean = false;\r\n    public showInsert: boolean = true;\r\n    public showRandomize: boolean = false;\r\n    public showSearch: boolean = false;\r\n    public showField: boolean = true;\r\n    public insert_name: string = \"Validate\";\r\n\r\n    constructor(\r\n        animator: AnimationPlayer,\r\n    ) {\r\n        this.graph = new FA_Graph();\r\n        this.animator = animator;\r\n    }\r\n\r\n    getRandomInt(min: number, max: number): number {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n\r\n\r\n    /* generateNewColor(): Color {\r\n        let c: Color = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n        let exists = this.colorUsed.some(\r\n            (color) => color.r === c.r &&\r\n                color.g === c.g &&\r\n                color.b === c.b &&\r\n                color.a === c.a\r\n        );\r\n\r\n        let attemps = 0;\r\n\r\n        while (exists) {\r\n\r\n            if (attemps > 50) break;\r\n\r\n            c = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n            exists = this.colorUsed.some(\r\n                (color) => color.r === c.r &&\r\n                    color.g === c.g &&\r\n                    color.b === c.b &&\r\n                    color.a === c.a\r\n            );\r\n\r\n            attemps++;\r\n        }\r\n\r\n        this.colorUsed.push(c);\r\n\r\n        return c;\r\n    } */\r\n\r\n    parse(area: string) {\r\n\r\n        // Is code valid?\r\n        const lines = area.split(\"\\n\");\r\n        let valid = true;\r\n        let currentNodeValue: string = \"\";\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n\r\n            // Ignore comments\r\n            if (line.startsWith('#') || line.startsWith('//')) continue;\r\n\r\n            // If it doesn't start with a space, it is the start of a state definition\r\n            if (!line.startsWith(' ') && line.includes(':')) {\r\n                const value = line.split(\":\")[0];\r\n\r\n                if (this.graph.get_node(value) == null) this.graph.create_node(value);\r\n\r\n                currentNodeValue = value;\r\n            }\r\n\r\n            // If it does, it is a value in a state definition\r\n            else {\r\n\r\n                // Get rid of spaces\r\n                const new_line = line.replace(/\\s+/g, '');\r\n\r\n                // Check if there is a : - if so, its a value, if not, its either Start or Final keywords\r\n                if (new_line.includes(':')) {\r\n                    const pointer = new_line.split(\":\")[0];\r\n                    const weights = new_line\r\n                        .split(\":\")[1]\r\n                        .split(\",\")\r\n                        .map(w => w.trim());\r\n\r\n                    //this.states[currentState].push({state: state, values: values});\r\n\r\n                    if (this.graph.get_node(pointer) == null) this.graph.create_node(pointer);\r\n\r\n                    this.graph.add_node_pointers(currentNodeValue, weights, pointer);\r\n                }\r\n                // Keywords\r\n                else {\r\n\r\n                    // Set the starting state\r\n                    if (new_line.toUpperCase() === \"START\") {\r\n                        this.graph.set_starting_node(currentNodeValue);\r\n                    }\r\n\r\n                    // Add onto the final states\r\n                    if (new_line.toUpperCase() === \"FINAL\") {\r\n                        this.graph.add_final_node(currentNodeValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Is there a starting state? If not, cause error\r\n        if (!this.graph.has_starting_node()) {\r\n            valid = false;\r\n        }\r\n\r\n        // Is there any final states? Is not, cause error\r\n        if (!this.graph.has_one_final_node()) {\r\n            valid = false;\r\n        }\r\n\r\n        // If valid, generate animation / structure\r\n        if (valid) {\r\n\r\n            this.animator.addInstruction(new FAAddAllInstruction(this.graph));\r\n\r\n            /*\r\n            let indexStates : Record<string, number> | null = {};\r\n            let colorStates : Record<string, Color> = {};\r\n\r\n            let index = 0;\r\n            for (const state in this.states) {\r\n\r\n                indexStates[state] = index;\r\n                colorStates[state] = this.generateNewColor();\r\n\r\n                //const stateArray = this.states[state];\r\n\r\n                //stateArray.forEach((value) => {\r\n                //    this.animator.addInstruction(new FAAddInstruction(index, value, ))\r\n                //});\r\n\r\n                let isStarting = state === this.startingState;\r\n                let isFinal = this.finalStates.includes(state);\r\n\r\n                this.animator.addInstruction(new FAAddInstruction(index, state, Object.keys(this.states).length, this.states[state], indexStates, colorStates, isStarting, isFinal));\r\n\r\n                index += 1;\r\n            } */\r\n\r\n            this.animator.processInstructions();\r\n        }\r\n\r\n    }\r\n\r\n    clear(): void {\r\n        this.graph = new FA_Graph();\r\n        const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\r\n        svg.selectAll(\"*\").remove();\r\n\r\n    }\r\n\r\n    delete(value: string | number): void {\r\n    }\r\n\r\n    generate_random(min: number, max: number, size: number, allowStrings: boolean, allowNumbers: boolean, allowDecimal: boolean, maxDecimal: number, regex: string, stringLengthMin: number, stringLengthMax: number): void {\r\n    }\r\n\r\n    // Check to see if value is in FA\r\n    insert(value: string | number): void {\r\n\r\n        // Start from the starting node\r\n        let current_node = this.graph.get_starting_node();\r\n        let prev_node: FA_Node | null = null;\r\n\r\n        this.animator.addInstruction(new FAHighlightInstruction(current_node?.get_value() as string, \"\"));\r\n\r\n        // Validate each letter until input crash\r\n        for (let letter of value.toString()) {\r\n            const pointers = current_node?.get_pointers();\r\n\r\n            if (!pointers) return;\r\n\r\n            let found = false;\r\n\r\n            // Search through pointers to see if weight matches\r\n            pointers.forEach((weights: (string | number)[], node: FA_Node) => {\r\n                if (weights.includes(letter)) {\r\n                    prev_node = current_node;\r\n                    current_node = node;\r\n                    found = true;\r\n                }\r\n            });\r\n\r\n            // If no matches, input crash\r\n            if (!found) {\r\n                alert(\"Input Crash\");\r\n                return\r\n            }\r\n            else {\r\n                // Highlight path\r\n                if (prev_node != null) {\r\n                    this.animator.addInstruction(\r\n                        new FAHighlightInstruction(\r\n                            current_node?.get_value() as string,\r\n                            (prev_node as FA_Node).get_value() as string\r\n                        )\r\n                    );\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        // Check to see if the last landed node is a final state (If not, input crash)\r\n        if (current_node == null || !this.graph.is_final_node(current_node.get_value())) {\r\n            alert(\"Input Crash\");\r\n            return\r\n        }\r\n\r\n        this.animator.processInstructions();\r\n        alert(\"Yes, the string is in the machine!\");\r\n\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}