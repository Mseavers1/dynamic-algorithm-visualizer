{"ast":null,"code":"import * as d3 from \"d3\";\nexport class TreeAnimate {\n  constructor(setIsAnimating) {\n    this.setIsAnimating = setIsAnimating;\n    this.instructions = void 0;\n    this.current_nodes = void 0;\n    this.processInstructions = async svg => {\n      for (let instruction of this.instructions) {\n        if (instruction.type === 'add' && instruction.value) {\n          await this.addNode(svg, instruction);\n        }\n        if (instruction.type === 'swap') {\n          await this.swapNodes(svg, this.current_nodes[instruction.toIndex], this.current_nodes[instruction.fromIndex], instruction);\n        }\n        if (instruction.type === 'remove') {\n          await this.removeNode(svg, instruction);\n        }\n        if (instruction.type === 'clear') {\n          await this.clearNodes(svg, instruction).then(() => {\n            this.current_nodes = [];\n          });\n        }\n        if (instruction.type === 'instant_add' && instruction.value) {\n          await this.addNode(svg, instruction, true);\n        }\n      }\n      this.instructions = [];\n      this.setIsAnimating(false);\n    };\n    this.removeNode = (svg, instruction) => {\n      return new Promise(resolve => {\n        for (let i = 0; i < this.current_nodes.length; i++) {\n          if (this.current_nodes[i].index === instruction.index) {\n            this.fade_nodes_out(i);\n            break;\n          }\n        }\n        setTimeout(() => resolve(), 1000);\n      });\n    };\n    this.clearNodes = (svg, instruction) => {\n      return new Promise(resolve => {\n        for (let i = this.current_nodes.length - 1; i >= 0; i--) {\n          this.fade_nodes_out(i);\n        }\n        setTimeout(() => resolve(), 1000);\n      });\n    };\n    this.addNode = (svg, instruction, allAtOnce = false) => {\n      return new Promise(resolve => {\n        let allAtOnceSpeed = 1;\n        if (allAtOnce) allAtOnceSpeed = 0;\n        const position = this.getNodePosition(instruction.index);\n        const parentIndex = Math.floor((instruction.index - 1) / 2);\n        const hasParent = parentIndex >= 0 && this.current_nodes[parentIndex];\n\n        // Ensure there are groups for edges and nodes\n        let edgesGroup = svg.select(\"g.edges\");\n        let nodesGroup = svg.select(\"g.nodes\");\n        if (edgesGroup.empty()) {\n          edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\n        }\n        if (nodesGroup.empty()) {\n          nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\n        }\n        let edge = null;\n        if (hasParent) {\n          const parentPos = this.getNodePosition(parentIndex);\n          edge = edgesGroup.append(\"line\") // Append edge inside the 'edges' group\n          .attr(\"x1\", parentPos.x).attr(\"y1\", parentPos.y).attr(\"x2\", 200) // Temporary start position\n          .attr(\"y2\", 200).attr(\"stroke\", \"black\").attr(\"stroke-width\", 5).style(\"opacity\", 0);\n        }\n        const nodeElement = nodesGroup.append(\"circle\") // Append node inside the 'nodes' group\n        .attr(\"cx\", 200).attr(\"cy\", 200).attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0);\n        const label = nodesGroup.append(\"text\") // Append label inside the 'nodes' group\n        .attr(\"x\", 200).attr(\"y\", 200).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"white\").style(\"font-size\", \"12px\").text(instruction.value);\n        const newNode = {\n          node: nodeElement,\n          label: label,\n          parentEdge: edge,\n          index: instruction.index\n        };\n        this.current_nodes.push(newNode);\n\n        // Animate the node: fade in and move\n        nodeElement.transition().duration(1000).style(\"opacity\", 1).attr(\"cx\", position.x).attr(\"cy\", position.y);\n        label.transition().duration(1000).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y);\n        if (edge) {\n          edge.transition().duration(1000).style(\"opacity\", 1).attr(\"x2\", position.x).attr(\"y2\", position.y);\n        }\n        setTimeout(() => resolve(), 1000 * allAtOnceSpeed);\n      });\n    };\n    this.getNodePosition = index => {\n      if (index < 0 || isNaN(index)) return {\n        x: 0,\n        y: 0\n      };\n      if (index === 0) return {\n        x: 250,\n        y: 50\n      }; // Root at the center\n\n      const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\n      const xSpacing = 200 / (depth + 1); // Adjust x spacing\n      const ySpacing = 80; // Vertical spacing\n\n      const parentIndex = Math.floor((index - 1) / 2);\n      const parentPos = this.getNodePosition(parentIndex);\n      const isLeftChild = index % 2 === 1;\n      const xOffset = isLeftChild ? -xSpacing : xSpacing;\n      return {\n        x: parentPos.x + xOffset,\n        y: parentPos.y + ySpacing\n      };\n    };\n    this.animate = (update, duration = 1000) => {\n      return new Promise(resolve => {\n        const start = performance.now();\n        const step = timestamp => {\n          const progress = Math.min((timestamp - start) / duration, 1);\n          update(progress);\n          if (progress < 1) {\n            requestAnimationFrame(step);\n          } else {\n            resolve();\n          }\n        };\n        requestAnimationFrame(step);\n      });\n    };\n    this.swapNodes = (svg, nodeA, nodeB, instruction) => {\n      //alert(nodes.length);\n\n      return new Promise(resolve => {\n        const node1 = nodeA.node;\n        const label1 = nodeA.label;\n        const node2 = nodeB.node;\n        const label2 = nodeB.label;\n        const node1Position = {\n          x: parseFloat(node1.attr(\"cx\")),\n          y: parseFloat(node1.attr(\"cy\"))\n        };\n        const node2Position = {\n          x: parseFloat(node2.attr(\"cx\")),\n          y: parseFloat(node2.attr(\"cy\"))\n        };\n        this.animate(progress => {\n          const newX1 = node1Position.x + (node2Position.x - node1Position.x) * progress;\n          const newY1 = node1Position.y + (node2Position.y - node1Position.y) * progress;\n          const newX2 = node2Position.x + (node1Position.x - node2Position.x) * progress;\n          const newY2 = node2Position.y + (node1Position.y - node2Position.y) * progress;\n          node1.attr(\"cx\", newX1).attr(\"cy\", newY1);\n          label1.attr(\"x\", newX1).attr(\"y\", newY1);\n          node2.attr(\"cx\", newX2).attr(\"cy\", newY2);\n          label2.attr(\"x\", newX2).attr(\"y\", newY2);\n        }, 1000).then(() => {\n          // Swap the actual data reference\n          const temp = this.current_nodes[instruction.toIndex];\n          this.current_nodes[instruction.toIndex] = this.current_nodes[instruction.fromIndex];\n          this.current_nodes[instruction.fromIndex] = temp;\n          resolve();\n        });\n      });\n    };\n    this.instructions = [];\n    this.current_nodes = [];\n  }\n  add_instruction(instruction) {\n    this.instructions.push(instruction);\n  }\n  start_processing() {\n    this.setIsAnimating(true);\n    //alert(this.instructions)\n\n    const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\n    this.processInstructions(svg);\n  }\n  fade_nodes_out(i) {\n    this.current_nodes[i].node.transition().duration(500).style(\"opacity\", 0).remove();\n    this.current_nodes[i].label.transition().duration(500).style(\"opacity\", 0).remove();\n    if (this.current_nodes[i].parentEdge !== null) {\n      var _this$current_nodes$i;\n      (_this$current_nodes$i = this.current_nodes[i].parentEdge) === null || _this$current_nodes$i === void 0 ? void 0 : _this$current_nodes$i.transition().duration(500).style(\"opacity\", 0).remove();\n    }\n    this.current_nodes.splice(i, 1);\n  }\n}","map":{"version":3,"names":["d3","TreeAnimate","constructor","setIsAnimating","instructions","current_nodes","processInstructions","svg","instruction","type","value","addNode","swapNodes","toIndex","fromIndex","removeNode","clearNodes","then","Promise","resolve","i","length","index","fade_nodes_out","setTimeout","allAtOnce","allAtOnceSpeed","position","getNodePosition","parentIndex","Math","floor","hasParent","edgesGroup","select","nodesGroup","empty","append","attr","edge","parentPos","x","y","style","nodeElement","label","text","newNode","node","parentEdge","push","transition","duration","isNaN","depth","log2","xSpacing","ySpacing","isLeftChild","xOffset","animate","update","start","performance","now","step","timestamp","progress","min","requestAnimationFrame","nodeA","nodeB","node1","label1","node2","label2","node1Position","parseFloat","node2Position","newX1","newY1","newX2","newY2","temp","add_instruction","start_processing","remove","_this$current_nodes$i","splice"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/structures/tree_animator.ts"],"sourcesContent":["import {Instruction, NodeData} from \"../algorithms/tree_intructions\";\r\nimport * as d3 from \"d3\";\r\nimport {BaseType} from \"d3\";\r\n\r\nexport class TreeAnimate {\r\n\r\n    private instructions : Instruction[];\r\n    private current_nodes : NodeData[];\r\n\r\n    constructor(private setIsAnimating: (value: boolean) => void) {\r\n        this.instructions = [];\r\n        this.current_nodes = [];\r\n    }\r\n\r\n    add_instruction(instruction : Instruction) {\r\n        this.instructions.push(instruction);\r\n    }\r\n\r\n    start_processing() {\r\n\r\n        this.setIsAnimating(true);\r\n        //alert(this.instructions)\r\n\r\n        const svg = d3.select(\"#svg-container\")\r\n            .attr(\"width\", 500)\r\n            .attr(\"height\", 500);\r\n\r\n        this.processInstructions(svg);\r\n    }\r\n\r\n    processInstructions = async (svg: d3.Selection<BaseType, unknown, HTMLElement, any>) => {\r\n        for (let instruction of this.instructions) {\r\n            if (instruction.type === 'add' && instruction.value) {\r\n                await this.addNode(svg, instruction);\r\n            }\r\n\r\n            if (instruction.type === 'swap') {\r\n\r\n                await this.swapNodes(svg, this.current_nodes[instruction.toIndex as number], this.current_nodes[instruction.fromIndex as number], instruction);\r\n            }\r\n\r\n            if (instruction.type === 'remove') {\r\n                await this.removeNode(svg, instruction);\r\n            }\r\n\r\n            if (instruction.type === 'clear') {\r\n                await this.clearNodes(svg, instruction).then(() => {this.current_nodes = [];});\r\n            }\r\n\r\n            if (instruction.type === 'instant_add' && instruction.value) {\r\n                await this.addNode(svg, instruction, true);\r\n            }\r\n        }\r\n\r\n        this.instructions = [];\r\n        this.setIsAnimating(false);\r\n\r\n    };\r\n\r\n    removeNode = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>, instruction : Instruction) => {\r\n        return new Promise<void>((resolve) => {\r\n\r\n            for (let i = 0; i < this.current_nodes.length; i++) {\r\n\r\n                if (this.current_nodes[i].index === instruction.index) {\r\n                    this.fade_nodes_out(i)\r\n                    break;\r\n                }\r\n            }\r\n\r\n            setTimeout(() => resolve(), 1000);\r\n        });\r\n    }\r\n\r\n    clearNodes = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>, instruction : Instruction) => {\r\n        return new Promise<void>((resolve) => {\r\n\r\n            for (let i = this.current_nodes.length - 1; i >= 0; i--) {\r\n                this.fade_nodes_out(i)\r\n            }\r\n\r\n            setTimeout(() => resolve(), 1000);\r\n        });\r\n    }\r\n\r\n    fade_nodes_out(i : number) {\r\n        this.current_nodes[i].node.transition()\r\n            .duration(500)\r\n            .style(\"opacity\", 0)\r\n            .remove();\r\n\r\n        this.current_nodes[i].label.transition()\r\n            .duration(500)\r\n            .style(\"opacity\", 0)\r\n            .remove();\r\n\r\n        if (this.current_nodes[i].parentEdge !== null) {\r\n            this.current_nodes[i].parentEdge?.transition()\r\n                .duration(500)\r\n                .style(\"opacity\", 0)\r\n                .remove();\r\n        }\r\n\r\n        this.current_nodes.splice(i, 1);\r\n    }\r\n\r\n    addNode = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>, instruction: Instruction, allAtOnce: boolean = false) => {\r\n        return new Promise<void>((resolve) => {\r\n\r\n            let allAtOnceSpeed = 1;\r\n            if (allAtOnce) allAtOnceSpeed = 0;\r\n\r\n            const position = this.getNodePosition(instruction.index as number);\r\n            const parentIndex = Math.floor((instruction.index as number - 1) / 2);\r\n            const hasParent = parentIndex >= 0 && this.current_nodes[parentIndex];\r\n\r\n            // Ensure there are groups for edges and nodes\r\n            let edgesGroup = svg.select<SVGGElement>(\"g.edges\");\r\n            let nodesGroup = svg.select<SVGGElement>(\"g.nodes\");\r\n\r\n\r\n            if (edgesGroup.empty()) {\r\n                edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\r\n            }\r\n            if (nodesGroup.empty()) {\r\n                nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\r\n            }\r\n\r\n            let edge: d3.Selection<SVGLineElement, unknown, HTMLElement, any> | null = null;\r\n            if (hasParent) {\r\n                const parentPos = this.getNodePosition(parentIndex as number);\r\n                edge = edgesGroup.append(\"line\") // Append edge inside the 'edges' group\r\n                    .attr(\"x1\", parentPos.x)\r\n                    .attr(\"y1\", parentPos.y)\r\n                    .attr(\"x2\", 200)  // Temporary start position\r\n                    .attr(\"y2\", 200)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 5)\r\n                    .style(\"opacity\", 0);\r\n            }\r\n\r\n            const nodeElement = nodesGroup.append(\"circle\") // Append node inside the 'nodes' group\r\n                .attr(\"cx\", 200)\r\n                .attr(\"cy\", 200)\r\n                .attr(\"r\", 20)\r\n                .attr(\"class\", \"node\")\r\n                .style(\"opacity\", 0);\r\n\r\n            const label = nodesGroup.append(\"text\") // Append label inside the 'nodes' group\r\n                .attr(\"x\", 200)\r\n                .attr(\"y\", 200)\r\n                .attr(\"class\", \"label\")\r\n                .attr(\"text-anchor\", \"middle\")\r\n                .attr(\"alignment-baseline\", \"middle\")\r\n                .style(\"fill\", \"white\")\r\n                .style(\"font-size\", \"12px\")\r\n                .text(instruction.value as number | string);\r\n\r\n            const newNode: NodeData = { node: nodeElement, label: label, parentEdge: edge, index: instruction.index as number };\r\n            this.current_nodes.push(newNode);\r\n\r\n            // Animate the node: fade in and move\r\n            nodeElement.transition()\r\n                .duration(1000)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y);\r\n\r\n            label.transition()\r\n                .duration(1000)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y);\r\n\r\n            if (edge) {\r\n                edge.transition()\r\n                    .duration(1000)\r\n                    .style(\"opacity\", 1)\r\n                    .attr(\"x2\", position.x)\r\n                    .attr(\"y2\", position.y);\r\n            }\r\n\r\n            setTimeout(() => resolve(), 1000 * allAtOnceSpeed);\r\n        });\r\n    };\r\n\r\n\r\n    getNodePosition = (index: number): { x: number, y: number } => {\r\n        if (index < 0 || isNaN(index)) return { x: 0, y: 0 };\r\n        if (index === 0) return { x: 250, y: 50 }; // Root at the center\r\n\r\n        const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\r\n        const xSpacing = (200) / (depth + 1); // Adjust x spacing\r\n        const ySpacing = 80; // Vertical spacing\r\n\r\n        const parentIndex = Math.floor((index - 1) / 2);\r\n        const parentPos = this.getNodePosition(parentIndex);\r\n\r\n        const isLeftChild = index % 2 === 1;\r\n        const xOffset = isLeftChild ? -xSpacing : xSpacing;\r\n\r\n        return { x: parentPos.x + xOffset, y: parentPos.y + ySpacing };\r\n    };\r\n\r\n    animate = (update: (progress: number) => void, duration: number = 1000) => {\r\n        return new Promise<void>((resolve) => {\r\n            const start = performance.now();\r\n            const step = (timestamp: number) => {\r\n                const progress = Math.min((timestamp - start) / duration, 1);\r\n                update(progress);\r\n                if (progress < 1) {\r\n                    requestAnimationFrame(step);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n            requestAnimationFrame(step);\r\n        });\r\n    };\r\n\r\n\r\n    swapNodes = (\r\n        svg: d3.Selection<BaseType, unknown, HTMLElement, any>,\r\n        nodeA: NodeData,\r\n        nodeB: NodeData,\r\n        instruction: Instruction\r\n    ) => {\r\n\r\n        //alert(nodes.length);\r\n\r\n        return new Promise<void>((resolve) => {\r\n            const node1 = nodeA.node;\r\n            const label1 = nodeA.label;\r\n            const node2 = nodeB.node;\r\n            const label2 = nodeB.label;\r\n\r\n\r\n            const node1Position = { x: parseFloat(node1.attr(\"cx\")), y: parseFloat(node1.attr(\"cy\")) };\r\n            const node2Position = { x: parseFloat(node2.attr(\"cx\")), y: parseFloat(node2.attr(\"cy\")) };\r\n\r\n            this.animate((progress) => {\r\n                const newX1 = node1Position.x + (node2Position.x - node1Position.x) * progress;\r\n                const newY1 = node1Position.y + (node2Position.y - node1Position.y) * progress;\r\n                const newX2 = node2Position.x + (node1Position.x - node2Position.x) * progress;\r\n                const newY2 = node2Position.y + (node1Position.y - node2Position.y) * progress;\r\n\r\n                node1.attr(\"cx\", newX1).attr(\"cy\", newY1);\r\n                label1.attr(\"x\", newX1).attr(\"y\", newY1);\r\n                node2.attr(\"cx\", newX2).attr(\"cy\", newY2);\r\n                label2.attr(\"x\", newX2).attr(\"y\", newY2);\r\n            }, 1000).then(() => {\r\n                // Swap the actual data reference\r\n                const temp = this.current_nodes[instruction.toIndex as number];\r\n                this.current_nodes[instruction.toIndex as number] = this.current_nodes[instruction.fromIndex as number];\r\n                this.current_nodes[instruction.fromIndex as number] = temp;\r\n                resolve();\r\n            });\r\n        });\r\n    };\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}