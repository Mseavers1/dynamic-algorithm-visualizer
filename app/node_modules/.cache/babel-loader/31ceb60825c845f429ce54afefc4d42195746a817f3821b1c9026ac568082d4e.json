{"ast":null,"code":"import * as d3 from \"d3\";\nexport class FAAddInstruction {\n  constructor(index, value, numberOfStates, values, indexStates) {\n    this.value = void 0;\n    this.index = void 0;\n    this.numberOfStates = void 0;\n    this.indexStates = void 0;\n    this.values = void 0;\n    this.index = index;\n    this.value = value;\n    this.numberOfStates = numberOfStates;\n    this.indexStates = indexStates;\n    this.values = values;\n  }\n  async process(svg) {\n    const position = this.getPosition(this.index, this.numberOfStates, 350, 200);\n    let nodesGroup = svg.select(\"g.nodes\");\n    let edgesGroup = svg.select(\"g.edges\");\n    if (edgesGroup.empty()) {\n      edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\n    }\n    if (nodesGroup.empty()) {\n      nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\n    }\n    const nodeElement = nodesGroup.append(\"circle\").attr(\"cx\", 200).attr(\"cy\", 200).attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0);\n\n    // Creates the text label on screen\n    const label = nodesGroup.append(\"text\").attr(\"x\", 200).attr(\"y\", 200).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"white\").style(\"font-size\", \"12px\").text(this.value);\n    const defs = svg.append(\"defs\");\n    defs.append(\"marker\").attr(\"id\", \"arrow\").attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 20).attr(\"refY\", 5).attr(\"markerWidth\", 3).attr(\"markerHeight\", 3).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M0,0 L10,5 L0,10\") // Path of the arrowhead\n    .attr(\"fill\", \"black\"); // Arrow color\n\n    let edges = [];\n    let sEdges = [];\n    for (let i = 0; i < this.values.length; i++) {\n      const val = this.values[i];\n      if (this.indexStates[val.state] == this.index) {\n        const edge = edgesGroup.append(\"line\").attr(\"x1\", position.x).attr(\"y1\", position.y).attr(\"x2\", position.x).attr(\"y2\", position.y).attr(\"stroke\", \"black\").attr(\"stroke-width\", 5).style(\"opacity\", 0).attr(\"marker-end\", \"url(#arrow)\");\n        edges.push(edge);\n      } else {\n        const nodeRadius = 20; // Radius of the node\n        const loopRadius = 30; // How far the loop edge should be from the center of the node\n        const angle = Math.PI / 4; // Angle to rotate the loop\n\n        // 1. Define the loop path (a circular path around the node)\n        const loopPath = d3.arc().innerRadius(nodeRadius).outerRadius(nodeRadius + loopRadius).startAngle(0).endAngle(Math.PI * 2); // Full circle\n\n        // 2. Create the loop for the node\n        const edge = edgesGroup.append(\"path\").attr(\"d\", loopPath()).attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-width\", 3).style(\"opacity\", 1);\n\n        // 3. Optionally, add an arrow at the end of the loop\n        const defs = svg.append(\"defs\");\n        defs.append(\"marker\").attr(\"id\", \"arrow\").attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 5) // Position of the arrowhead relative to the midpoint\n        .attr(\"refY\", 5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M0,0 L10,5 L0,10\") // Path of the arrowhead\n        .attr(\"fill\", \"black\");\n\n        // Add the arrow at the end of the loop\n        edge.attr(\"marker-end\", \"url(#arrow)\");\n        edges.push(edge);\n      }\n    }\n    const nodeTransition = nodeElement.transition().duration(1000).style(\"opacity\", 1).attr(\"cx\", position.x).attr(\"cy\", position.y);\n    const labelTransition = label.transition().duration(1000).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y);\n    let edgeTransitionPromises = [];\n    if (edges.length > 0) {\n      for (let i = 0; i < edges.length; i++) {\n        const edge = edges[i];\n        const val = this.values[i];\n        const pos = this.getPosition(this.indexStates[val.state], this.numberOfStates, 350, 200);\n        const edgeTransition = edge.transition().duration(1000).style(\"opacity\", 1).attr(\"x2\", pos.x).attr(\"y2\", pos.y);\n        edgeTransitionPromises.push(edgeTransition.end());\n      }\n    }\n    await Promise.all([nodeTransition.end(), labelTransition.end(), edgeTransitionPromises]);\n  }\n  getPosition(index, numberOfStates, centerX, centerY, radius = 100) {\n    const angle = 2 * Math.PI * index / numberOfStates;\n\n    // Calculate x and y coordinates using polar to Cartesian conversion\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return {\n      x: x + centerX,\n      y: y + centerY\n    };\n  }\n}","map":{"version":3,"names":["d3","FAAddInstruction","constructor","index","value","numberOfStates","values","indexStates","process","svg","position","getPosition","nodesGroup","select","edgesGroup","empty","append","attr","nodeElement","style","label","text","defs","edges","sEdges","i","length","val","state","edge","x","y","push","nodeRadius","loopRadius","angle","Math","PI","loopPath","arc","innerRadius","outerRadius","startAngle","endAngle","nodeTransition","transition","duration","labelTransition","edgeTransitionPromises","pos","edgeTransition","end","Promise","all","centerX","centerY","radius","cos","sin"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {Node} from \"../pictures/node\";\r\nimport {stateValues} from \"../algorithms/fa_transition\";\r\nimport * as d3 from \"d3\";\r\n\r\nexport class FAAddInstruction implements Instruction {\r\n\r\n    value: number | string;\r\n    index: number;\r\n    numberOfStates: number;\r\n    indexStates: Record<string, number>;\r\n    values: stateValues[];\r\n\r\n    constructor(index: number, value: number | string, numberOfStates: number, values: stateValues[], indexStates: Record<string, number>) {\r\n        this.index = index;\r\n        this.value = value;\r\n        this.numberOfStates = numberOfStates;\r\n        this.indexStates = indexStates;\r\n        this.values = values;\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n\r\n        const position = this.getPosition(this.index, this.numberOfStates, 350, 200);\r\n\r\n        let nodesGroup = svg.select<SVGGElement>(\"g.nodes\");\r\n\r\n        let edgesGroup = svg.select<SVGGElement>(\"g.edges\");\r\n\r\n        if (edgesGroup.empty()) {\r\n            edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\r\n        }\r\n\r\n\r\n        if (nodesGroup.empty()) {\r\n            nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\r\n        }\r\n\r\n        const nodeElement = nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", 200)\r\n            .attr(\"cy\", 200)\r\n            .attr(\"r\", 20)\r\n            .attr(\"class\", \"node\")\r\n            .style(\"opacity\", 0);\r\n\r\n        // Creates the text label on screen\r\n        const label = nodesGroup.append(\"text\")\r\n            .attr(\"x\", 200)\r\n            .attr(\"y\", 200)\r\n            .attr(\"class\", \"label\")\r\n            .attr(\"text-anchor\", \"middle\")\r\n            .attr(\"alignment-baseline\", \"middle\")\r\n            .style(\"fill\", \"white\")\r\n            .style(\"font-size\", \"12px\")\r\n            .text(this.value);\r\n\r\n        const defs = svg.append(\"defs\");\r\n\r\n        defs.append(\"marker\")\r\n            .attr(\"id\", \"arrow\")\r\n            .attr(\"viewBox\", \"0 0 10 10\")\r\n            .attr(\"refX\", 20)\r\n            .attr(\"refY\", 5)\r\n            .attr(\"markerWidth\", 3)\r\n            .attr(\"markerHeight\", 3)\r\n            .attr(\"orient\", \"auto\")\r\n            .append(\"path\")\r\n            .attr(\"d\", \"M0,0 L10,5 L0,10\") // Path of the arrowhead\r\n            .attr(\"fill\", \"black\"); // Arrow color\r\n\r\n        let edges: d3.Selection<SVGLineElement, unknown, HTMLElement, any>[] = [];\r\n        let sEdges = []\r\n\r\n        for (let i = 0; i < this.values.length; i++) {\r\n\r\n            const val = this.values[i];\r\n\r\n            if (this.indexStates[val.state] == this.index) {\r\n\r\n                const edge = edgesGroup.append(\"line\")\r\n                    .attr(\"x1\", position.x)\r\n                    .attr(\"y1\", position.y)\r\n                    .attr(\"x2\", position.x)\r\n                    .attr(\"y2\", position.y)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 5)\r\n                    .style(\"opacity\", 0)\r\n                    .attr(\"marker-end\", \"url(#arrow)\");\r\n\r\n                edges.push(edge);\r\n            }\r\n            else {\r\n\r\n                const nodeRadius = 20; // Radius of the node\r\n                const loopRadius = 30; // How far the loop edge should be from the center of the node\r\n                const angle = Math.PI / 4; // Angle to rotate the loop\r\n\r\n                // 1. Define the loop path (a circular path around the node)\r\n                const loopPath = d3.arc()\r\n                    .innerRadius(nodeRadius)\r\n                    .outerRadius(nodeRadius + loopRadius)\r\n                    .startAngle(0)\r\n                    .endAngle(Math.PI * 2); // Full circle\r\n\r\n                // 2. Create the loop for the node\r\n                const edge = edgesGroup.append(\"path\")\r\n                    .attr(\"d\", loopPath())\r\n                    .attr(\"fill\", \"none\")\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 3)\r\n                    .style(\"opacity\", 1);\r\n\r\n                // 3. Optionally, add an arrow at the end of the loop\r\n                const defs = svg.append(\"defs\");\r\n\r\n                defs.append(\"marker\")\r\n                    .attr(\"id\", \"arrow\")\r\n                    .attr(\"viewBox\", \"0 0 10 10\")\r\n                    .attr(\"refX\", 5)  // Position of the arrowhead relative to the midpoint\r\n                    .attr(\"refY\", 5)\r\n                    .attr(\"markerWidth\", 6)\r\n                    .attr(\"markerHeight\", 6)\r\n                    .attr(\"orient\", \"auto\")\r\n                    .append(\"path\")\r\n                    .attr(\"d\", \"M0,0 L10,5 L0,10\") // Path of the arrowhead\r\n                    .attr(\"fill\", \"black\");\r\n\r\n                // Add the arrow at the end of the loop\r\n                edge.attr(\"marker-end\", \"url(#arrow)\");\r\n\r\n                edges.push(edge);\r\n            }\r\n        }\r\n\r\n        const nodeTransition = nodeElement.transition()\r\n            .duration(1000)\r\n            .style(\"opacity\", 1)\r\n            .attr(\"cx\", position.x)\r\n            .attr(\"cy\", position.y)\r\n\r\n        const labelTransition = label.transition()\r\n            .duration(1000)\r\n            .style(\"opacity\", 1)\r\n            .attr(\"x\", position.x)\r\n            .attr(\"y\", position.y)\r\n\r\n        let edgeTransitionPromises : Promise<void>[] = [];\r\n\r\n        if (edges.length > 0) {\r\n\r\n            for (let i = 0; i < edges.length; i++) {\r\n                const edge = edges[i];\r\n                const val = this.values[i];\r\n\r\n                const pos = this.getPosition(this.indexStates[val.state], this.numberOfStates, 350, 200);\r\n\r\n                const edgeTransition = edge.transition()\r\n                    .duration(1000)\r\n                    .style(\"opacity\", 1)\r\n                    .attr(\"x2\", pos.x)\r\n                    .attr(\"y2\", pos.y);\r\n\r\n                edgeTransitionPromises.push(edgeTransition.end());\r\n            }\r\n        }\r\n\r\n        await Promise.all([nodeTransition.end(), labelTransition.end(), edgeTransitionPromises]);\r\n    }\r\n\r\n    getPosition(index: number, numberOfStates: number, centerX: number, centerY: number, radius: number = 100) {\r\n        const angle = (2 * Math.PI * index) / numberOfStates;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}