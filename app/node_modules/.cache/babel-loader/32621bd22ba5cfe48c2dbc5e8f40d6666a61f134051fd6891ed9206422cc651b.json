{"ast":null,"code":"import{FA_Graph}from\"../structures/fa_graph\";import{FAAddAllInstruction}from\"../Instructions/fa_add_all_instruction\";import*as d3 from\"d3\";import{FAHighlightInstruction}from\"../Instructions/highlight_fa_node_instruction\";import{FAAddInputInstruction}from\"../Instructions/fa_add_input_instruction\";import{FAFadeAllInstruction}from\"../Instructions/fa_fade_all_instruction\";import{FAShowArrowInstruction}from\"../Instructions/fa_show_arrow_instruction\";import{FAClearInputInstruction}from\"../Instructions/fa_clear_input_instruction\";import{FAShowStateInstruction}from\"../Instructions/fa_show_state_instruction\";export class FATransition{constructor(animator){this.graph=void 0;this.animator=void 0;this.showClear=true;this.showDelete=false;this.showInsert=true;this.showRandomize=false;this.showSearch=false;this.showField=true;this.insert_name=\"Validate\";this.graph=new FA_Graph();this.animator=animator;}getRandomInt(min,max){return Math.floor(Math.random()*(max-min+1))+min;}/* generateNewColor(): Color {\r\n        let c: Color = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n        let exists = this.colorUsed.some(\r\n            (color) => color.r === c.r &&\r\n                color.g === c.g &&\r\n                color.b === c.b &&\r\n                color.a === c.a\r\n        );\r\n\r\n        let attemps = 0;\r\n\r\n        while (exists) {\r\n\r\n            if (attemps > 50) break;\r\n\r\n            c = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n            exists = this.colorUsed.some(\r\n                (color) => color.r === c.r &&\r\n                    color.g === c.g &&\r\n                    color.b === c.b &&\r\n                    color.a === c.a\r\n            );\r\n\r\n            attemps++;\r\n        }\r\n\r\n        this.colorUsed.push(c);\r\n\r\n        return c;\r\n    } */parse(area){// Is code valid?\nconst lines=area.split(\"\\n\");let valid=true;let currentNodeValue=\"\";for(let i=0;i<lines.length;i++){const line=lines[i];// Ignore comments\nif(line.startsWith('#')||line.startsWith('//'))continue;// If it doesn't start with a space, it is the start of a state definition\nif(!line.startsWith(' ')&&line.includes(':')){const value=line.split(\":\")[0];if(this.graph.get_node(value)==null)this.graph.create_node(value);currentNodeValue=value;}// If it does, it is a value in a state definition\nelse{// Get rid of spaces\nconst new_line=line.replace(/\\s+/g,'');// Check if there is a : - if so, its a value, if not, its either Start or Final keywords\nif(new_line.includes(':')){const pointer=new_line.split(\":\")[0];const weights=new_line.split(\":\")[1].split(\",\").map(w=>w.trim());//this.states[currentState].push({state: state, values: values});\nif(this.graph.get_node(pointer)==null)this.graph.create_node(pointer);this.graph.add_node_pointers(currentNodeValue,weights,pointer);}// Keywords\nelse{// Set the starting state\nif(new_line.toUpperCase()===\"START\"){this.graph.set_starting_node(currentNodeValue);}// Add onto the final states\nif(new_line.toUpperCase()===\"FINAL\"){this.graph.add_final_node(currentNodeValue);}}}}// Is there a starting state? If not, cause error\nif(!this.graph.has_starting_node()){valid=false;}// Is there any final states? Is not, cause error\nif(!this.graph.has_one_final_node()){valid=false;}// If valid, generate animation / structure\nif(valid){this.animator.addInstruction(new FAAddAllInstruction(this.graph));/*\r\n            let indexStates : Record<string, number> | null = {};\r\n            let colorStates : Record<string, Color> = {};\r\n\r\n            let index = 0;\r\n            for (const state in this.states) {\r\n\r\n                indexStates[state] = index;\r\n                colorStates[state] = this.generateNewColor();\r\n\r\n                //const stateArray = this.states[state];\r\n\r\n                //stateArray.forEach((value) => {\r\n                //    this.animator.addInstruction(new FAAddInstruction(index, value, ))\r\n                //});\r\n\r\n                let isStarting = state === this.startingState;\r\n                let isFinal = this.finalStates.includes(state);\r\n\r\n                this.animator.addInstruction(new FAAddInstruction(index, state, Object.keys(this.states).length, this.states[state], indexStates, colorStates, isStarting, isFinal));\r\n\r\n                index += 1;\r\n            } */this.animator.processInstructions();}}clear(){this.graph=new FA_Graph();const svg=d3.select(\"#svg-container\").attr(\"width\",500).attr(\"height\",500);svg.selectAll(\"*\").remove();}delete(value){}generate_random(min,max,size,allowStrings,allowNumbers,allowDecimal,maxDecimal,regex,stringLengthMin,stringLengthMax){}// Check to see if value is in FA\ninsert(value){var _current_node;// If there are no nodes in graph or input is empty - stop\nif(this.graph.get_nodes().size<=0||value==\"\")return;this.animator.addInstruction(new FAClearInputInstruction());// Start from the starting node\nlet current_node=this.graph.get_starting_node();let prev_node=null;this.animator.addInstruction(new FAAddInputInstruction(value));this.animator.addInstruction(new FAFadeAllInstruction());this.animator.addInstruction(new FAHighlightInstruction((_current_node=current_node)===null||_current_node===void 0?void 0:_current_node.get_value(),\"START\"));this.animator.addInstruction(new FAFadeAllInstruction());let i=0;// Validate each letter until input crash\nfor(let letter of value.toString()){var _current_node2;this.animator.addInstruction(new FAShowArrowInstruction(i++));const pointers=(_current_node2=current_node)===null||_current_node2===void 0?void 0:_current_node2.get_pointers();if(!pointers)return;let found=false;// Search through pointers to see if weight matches\npointers.forEach((weights,node)=>{if(weights.includes(letter)){prev_node=current_node;current_node=node;found=true;}});// If no matches, input crash\nif(!found){this.animator.addInstruction(new FAFadeAllInstruction());this.animator.addInstruction(new FAShowStateInstruction(false));this.animator.processInstructions();return;}else{if(prev_node!=null){var _current_node3;this.animator.addInstruction(new FAFadeAllInstruction());this.animator.addInstruction(new FAHighlightInstruction(prev_node.get_value(),(_current_node3=current_node)===null||_current_node3===void 0?void 0:_current_node3.get_value()));}}}// Check to see if the last landed node is a final state (If not, input crash)\nif(current_node==null||!this.graph.is_final_node(current_node.get_value())){this.animator.addInstruction(new FAShowStateInstruction(false));}else{this.animator.addInstruction(new FAShowStateInstruction(true));}this.animator.processInstructions();//alert(\"Yes, the string is in the machine!\");\n}}","map":{"version":3,"names":["FA_Graph","FAAddAllInstruction","d3","FAHighlightInstruction","FAAddInputInstruction","FAFadeAllInstruction","FAShowArrowInstruction","FAClearInputInstruction","FAShowStateInstruction","FATransition","constructor","animator","graph","showClear","showDelete","showInsert","showRandomize","showSearch","showField","insert_name","getRandomInt","min","max","Math","floor","random","parse","area","lines","split","valid","currentNodeValue","i","length","line","startsWith","includes","value","get_node","create_node","new_line","replace","pointer","weights","map","w","trim","add_node_pointers","toUpperCase","set_starting_node","add_final_node","has_starting_node","has_one_final_node","addInstruction","processInstructions","clear","svg","select","attr","selectAll","remove","delete","generate_random","size","allowStrings","allowNumbers","allowDecimal","maxDecimal","regex","stringLengthMin","stringLengthMax","insert","_current_node","get_nodes","current_node","get_starting_node","prev_node","get_value","letter","toString","_current_node2","pointers","get_pointers","found","forEach","node","_current_node3","is_final_node"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/fa_transition.tsx"],"sourcesContent":["import {Algorithm} from \"./algorithm_interface\";\r\nimport {AnimationPlayer} from \"../animation_player\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\nimport {FAAddAllInstruction} from \"../Instructions/fa_add_all_instruction\";\r\nimport * as d3 from \"d3\";\r\nimport {FAHighlightInstruction} from \"../Instructions/highlight_fa_node_instruction\";\r\nimport {FA_Node} from \"../structures/fa_node\";\r\nimport {FAAddInputInstruction} from \"../Instructions/fa_add_input_instruction\";\r\nimport {FAFadeAllInstruction} from \"../Instructions/fa_fade_all_instruction\";\r\nimport {FAShowArrowInstruction} from \"../Instructions/fa_show_arrow_instruction\";\r\nimport {FAClearInputInstruction} from \"../Instructions/fa_clear_input_instruction\";\r\nimport {FAShowStateInstruction} from \"../Instructions/fa_show_state_instruction\";\r\n\r\nexport type stateValues = {\r\n    state: string;\r\n    values: string[];\r\n}\r\n\r\nexport class FATransition implements Algorithm {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    private animator: AnimationPlayer;\r\n\r\n    public showClear: boolean = true;\r\n    public showDelete: boolean = false;\r\n    public showInsert: boolean = true;\r\n    public showRandomize: boolean = false;\r\n    public showSearch: boolean = false;\r\n    public showField: boolean = true;\r\n    public insert_name: string = \"Validate\";\r\n\r\n    constructor(\r\n        animator: AnimationPlayer,\r\n    ) {\r\n        this.graph = new FA_Graph();\r\n        this.animator = animator;\r\n    }\r\n\r\n    getRandomInt(min: number, max: number): number {\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n\r\n\r\n    /* generateNewColor(): Color {\r\n        let c: Color = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n        let exists = this.colorUsed.some(\r\n            (color) => color.r === c.r &&\r\n                color.g === c.g &&\r\n                color.b === c.b &&\r\n                color.a === c.a\r\n        );\r\n\r\n        let attemps = 0;\r\n\r\n        while (exists) {\r\n\r\n            if (attemps > 50) break;\r\n\r\n            c = {r: this.getRandomInt(0, 255), g: this.getRandomInt(0, 255), b: this.getRandomInt(0, 255), a: 1};\r\n\r\n            exists = this.colorUsed.some(\r\n                (color) => color.r === c.r &&\r\n                    color.g === c.g &&\r\n                    color.b === c.b &&\r\n                    color.a === c.a\r\n            );\r\n\r\n            attemps++;\r\n        }\r\n\r\n        this.colorUsed.push(c);\r\n\r\n        return c;\r\n    } */\r\n\r\n    parse(area: string) {\r\n\r\n        // Is code valid?\r\n        const lines = area.split(\"\\n\");\r\n        let valid = true;\r\n        let currentNodeValue: string = \"\";\r\n\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n\r\n            // Ignore comments\r\n            if (line.startsWith('#') || line.startsWith('//')) continue;\r\n\r\n            // If it doesn't start with a space, it is the start of a state definition\r\n            if (!line.startsWith(' ') && line.includes(':')) {\r\n                const value = line.split(\":\")[0];\r\n\r\n                if (this.graph.get_node(value) == null) this.graph.create_node(value);\r\n\r\n                currentNodeValue = value;\r\n            }\r\n\r\n            // If it does, it is a value in a state definition\r\n            else {\r\n\r\n                // Get rid of spaces\r\n                const new_line = line.replace(/\\s+/g, '');\r\n\r\n                // Check if there is a : - if so, its a value, if not, its either Start or Final keywords\r\n                if (new_line.includes(':')) {\r\n                    const pointer = new_line.split(\":\")[0];\r\n                    const weights = new_line\r\n                        .split(\":\")[1]\r\n                        .split(\",\")\r\n                        .map(w => w.trim());\r\n\r\n                    //this.states[currentState].push({state: state, values: values});\r\n\r\n                    if (this.graph.get_node(pointer) == null) this.graph.create_node(pointer);\r\n\r\n                    this.graph.add_node_pointers(currentNodeValue, weights, pointer);\r\n                }\r\n                // Keywords\r\n                else {\r\n\r\n                    // Set the starting state\r\n                    if (new_line.toUpperCase() === \"START\") {\r\n                        this.graph.set_starting_node(currentNodeValue);\r\n                    }\r\n\r\n                    // Add onto the final states\r\n                    if (new_line.toUpperCase() === \"FINAL\") {\r\n                        this.graph.add_final_node(currentNodeValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Is there a starting state? If not, cause error\r\n        if (!this.graph.has_starting_node()) {\r\n            valid = false;\r\n        }\r\n\r\n        // Is there any final states? Is not, cause error\r\n        if (!this.graph.has_one_final_node()) {\r\n            valid = false;\r\n        }\r\n\r\n        // If valid, generate animation / structure\r\n        if (valid) {\r\n\r\n            this.animator.addInstruction(new FAAddAllInstruction(this.graph));\r\n\r\n            /*\r\n            let indexStates : Record<string, number> | null = {};\r\n            let colorStates : Record<string, Color> = {};\r\n\r\n            let index = 0;\r\n            for (const state in this.states) {\r\n\r\n                indexStates[state] = index;\r\n                colorStates[state] = this.generateNewColor();\r\n\r\n                //const stateArray = this.states[state];\r\n\r\n                //stateArray.forEach((value) => {\r\n                //    this.animator.addInstruction(new FAAddInstruction(index, value, ))\r\n                //});\r\n\r\n                let isStarting = state === this.startingState;\r\n                let isFinal = this.finalStates.includes(state);\r\n\r\n                this.animator.addInstruction(new FAAddInstruction(index, state, Object.keys(this.states).length, this.states[state], indexStates, colorStates, isStarting, isFinal));\r\n\r\n                index += 1;\r\n            } */\r\n\r\n            this.animator.processInstructions();\r\n        }\r\n\r\n    }\r\n\r\n    clear(): void {\r\n        this.graph = new FA_Graph();\r\n        const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\r\n        svg.selectAll(\"*\").remove();\r\n\r\n    }\r\n\r\n    delete(value: string | number): void {\r\n    }\r\n\r\n    generate_random(min: number, max: number, size: number, allowStrings: boolean, allowNumbers: boolean, allowDecimal: boolean, maxDecimal: number, regex: string, stringLengthMin: number, stringLengthMax: number): void {\r\n    }\r\n\r\n    // Check to see if value is in FA\r\n    insert(value: string | number): void {\r\n\r\n        // If there are no nodes in graph or input is empty - stop\r\n        if (this.graph.get_nodes().size <= 0 || value == \"\") return;\r\n\r\n        this.animator.addInstruction(new FAClearInputInstruction());\r\n\r\n        // Start from the starting node\r\n        let current_node = this.graph.get_starting_node();\r\n        let prev_node: FA_Node | null = null;\r\n\r\n        this.animator.addInstruction(new FAAddInputInstruction((value as string)));\r\n        this.animator.addInstruction(new FAFadeAllInstruction());\r\n        this.animator.addInstruction(new FAHighlightInstruction(current_node?.get_value() as string, \"START\"));\r\n        this.animator.addInstruction(new FAFadeAllInstruction());\r\n\r\n        let i = 0;\r\n\r\n        // Validate each letter until input crash\r\n        for (let letter of value.toString()) {\r\n            this.animator.addInstruction(new FAShowArrowInstruction(i++));\r\n            const pointers = current_node?.get_pointers();\r\n\r\n            if (!pointers) return;\r\n\r\n            let found = false;\r\n\r\n            // Search through pointers to see if weight matches\r\n            pointers.forEach((weights: (string | number)[], node: FA_Node) => {\r\n                if (weights.includes(letter)) {\r\n                    prev_node = current_node;\r\n                    current_node = node;\r\n                    found = true;\r\n                }\r\n            });\r\n\r\n            // If no matches, input crash\r\n            if (!found) {\r\n                this.animator.addInstruction(new FAFadeAllInstruction());\r\n                this.animator.addInstruction(new FAShowStateInstruction(false));\r\n\r\n                this.animator.processInstructions();\r\n                return;\r\n            } else {\r\n\r\n                if (prev_node != null) {\r\n\r\n                    this.animator.addInstruction(new FAFadeAllInstruction());\r\n\r\n                    this.animator.addInstruction(\r\n                        new FAHighlightInstruction(\r\n                            (prev_node as FA_Node).get_value() as string,\r\n                            current_node?.get_value() as string\r\n                        )\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check to see if the last landed node is a final state (If not, input crash)\r\n        if (current_node == null || !this.graph.is_final_node(current_node.get_value())) {\r\n            this.animator.addInstruction(new FAShowStateInstruction(false));\r\n        } else {\r\n            this.animator.addInstruction(new FAShowStateInstruction(true));\r\n        }\r\n\r\n        this.animator.processInstructions();\r\n        //alert(\"Yes, the string is in the machine!\");\r\n\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}