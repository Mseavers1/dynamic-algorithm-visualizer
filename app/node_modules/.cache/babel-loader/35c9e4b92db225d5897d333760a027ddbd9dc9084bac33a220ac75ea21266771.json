{"ast":null,"code":"import { BinaryTree } from \"../structures/binary_tree\";\nexport class MinHeap {\n  constructor(isDynamicSize, animator) {\n    this.isDynamicSize = isDynamicSize;\n    this.tree = void 0;\n    this.animator = void 0;\n    this.tree = new BinaryTree();\n    this.animator = animator;\n  }\n  insert(value) {\n    var _this$tree;\n    (_this$tree = this.tree) === null || _this$tree === void 0 ? void 0 : _this$tree.add(value);\n    const newInstruction = {\n      type: 'add',\n      value: value,\n      index: this.tree.length - 1\n    };\n\n    //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\n    this.animator.add_instruction(newInstruction);\n    this.heapify(this.tree.length);\n    this.animator.start_processing();\n\n    //alert(this.tree?.get_current_height())\n\n    //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\n  }\n  delete(value) {\n    var _this$tree2;\n    (_this$tree2 = this.tree) === null || _this$tree2 === void 0 ? void 0 : _this$tree2.remove();\n  }\n  heapify(cur_index) {\n    // At root, do not heapify.\n    if (cur_index == 1) return;\n\n    // Check if parent is less than the current index\n    const cur = this.tree.get(cur_index);\n    const par_index = this.tree.get_parent(cur_index);\n    const par_val = this.tree.get(par_index);\n    if (cur >= par_val) return;\n\n    // If so swap the indexes\n    this.tree.swap(cur_index, par_index);\n    const newInstruction = {\n      type: 'swap',\n      fromIndex: par_index - 1,\n      toIndex: cur_index - 1\n    };\n\n    //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\n    this.animator.add_instruction(newInstruction);\n\n    // Heapify on the new cur index\n    this.heapify(par_index);\n  }\n}","map":{"version":3,"names":["BinaryTree","MinHeap","constructor","isDynamicSize","animator","tree","insert","value","_this$tree","add","newInstruction","type","index","length","add_instruction","heapify","start_processing","delete","_this$tree2","remove","cur_index","cur","get","par_index","get_parent","par_val","swap","fromIndex","toIndex"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/min_heap.tsx"],"sourcesContent":["import { Algorithm } from \"./algorithm_interface\";\r\nimport {BinaryTree} from \"../structures/binary_tree\";\r\n\r\nimport {Instruction} from \"./tree_intructions\";\r\nimport React from \"react\";\r\nimport {TreeAnimate} from \"../structures/tree_animator\";\r\n\r\nexport class MinHeap implements Algorithm {\r\n\r\n    private tree : BinaryTree;\r\n\r\n    private animator: TreeAnimate;\r\n\r\n    constructor(\r\n        private isDynamicSize: boolean,\r\n        animator: TreeAnimate,\r\n    ) {\r\n        this.tree = new BinaryTree();\r\n        this.animator = animator;\r\n    }\r\n\r\n    insert(value: string | number) : void {\r\n\r\n        this.tree?.add(value);\r\n\r\n        const newInstruction: Instruction = {\r\n            type: 'add',\r\n            value: value,\r\n            index: this.tree.length - 1,\r\n        };\r\n\r\n        //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\r\n        this.animator.add_instruction(newInstruction);\r\n\r\n        this.heapify(this.tree.length);\r\n\r\n        this.animator.start_processing()\r\n\r\n        //alert(this.tree?.get_current_height())\r\n\r\n        //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\r\n\r\n    }\r\n\r\n    delete(value: string | number) : void {\r\n\r\n        \r\n\r\n        this.tree?.remove()\r\n    }\r\n\r\n    heapify(cur_index : number): void {\r\n\r\n        // At root, do not heapify.\r\n        if (cur_index == 1) return;\r\n\r\n        // Check if parent is less than the current index\r\n        const cur = this.tree.get(cur_index);\r\n        const par_index = this.tree.get_parent(cur_index);\r\n        const par_val = this.tree.get(par_index);\r\n\r\n        if (cur >= par_val) return;\r\n\r\n        // If so swap the indexes\r\n        this.tree.swap(cur_index, par_index);\r\n\r\n        const newInstruction: Instruction = {\r\n            type: 'swap',\r\n            fromIndex: par_index - 1,\r\n            toIndex: cur_index - 1,\r\n        };\r\n\r\n        //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\r\n        this.animator.add_instruction(newInstruction);\r\n\r\n        // Heapify on the new cur index\r\n        this.heapify(par_index);\r\n    }\r\n}\r\n\r\n"],"mappings":"AACA,SAAQA,UAAU,QAAO,2BAA2B;AAMpD,OAAO,MAAMC,OAAO,CAAsB;EAMtCC,WAAWA,CACCC,aAAsB,EAC9BC,QAAqB,EACvB;IAAA,KAFUD,aAAsB,GAAtBA,aAAsB;IAAA,KAL1BE,IAAI;IAAA,KAEJD,QAAQ;IAMZ,IAAI,CAACC,IAAI,GAAG,IAAIL,UAAU,CAAC,CAAC;IAC5B,IAAI,CAACI,QAAQ,GAAGA,QAAQ;EAC5B;EAEAE,MAAMA,CAACC,KAAsB,EAAS;IAAA,IAAAC,UAAA;IAElC,CAAAA,UAAA,OAAI,CAACH,IAAI,cAAAG,UAAA,uBAATA,UAAA,CAAWC,GAAG,CAACF,KAAK,CAAC;IAErB,MAAMG,cAA2B,GAAG;MAChCC,IAAI,EAAE,KAAK;MACXJ,KAAK,EAAEA,KAAK;MACZK,KAAK,EAAE,IAAI,CAACP,IAAI,CAACQ,MAAM,GAAG;IAC9B,CAAC;;IAED;IACA,IAAI,CAACT,QAAQ,CAACU,eAAe,CAACJ,cAAc,CAAC;IAE7C,IAAI,CAACK,OAAO,CAAC,IAAI,CAACV,IAAI,CAACQ,MAAM,CAAC;IAE9B,IAAI,CAACT,QAAQ,CAACY,gBAAgB,CAAC,CAAC;;IAEhC;;IAEA;EAEJ;EAEAC,MAAMA,CAACV,KAAsB,EAAS;IAAA,IAAAW,WAAA;IAIlC,CAAAA,WAAA,OAAI,CAACb,IAAI,cAAAa,WAAA,uBAATA,WAAA,CAAWC,MAAM,CAAC,CAAC;EACvB;EAEAJ,OAAOA,CAACK,SAAkB,EAAQ;IAE9B;IACA,IAAIA,SAAS,IAAI,CAAC,EAAE;;IAEpB;IACA,MAAMC,GAAG,GAAG,IAAI,CAAChB,IAAI,CAACiB,GAAG,CAACF,SAAS,CAAC;IACpC,MAAMG,SAAS,GAAG,IAAI,CAAClB,IAAI,CAACmB,UAAU,CAACJ,SAAS,CAAC;IACjD,MAAMK,OAAO,GAAG,IAAI,CAACpB,IAAI,CAACiB,GAAG,CAACC,SAAS,CAAC;IAExC,IAAIF,GAAG,IAAII,OAAO,EAAE;;IAEpB;IACA,IAAI,CAACpB,IAAI,CAACqB,IAAI,CAACN,SAAS,EAAEG,SAAS,CAAC;IAEpC,MAAMb,cAA2B,GAAG;MAChCC,IAAI,EAAE,MAAM;MACZgB,SAAS,EAAEJ,SAAS,GAAG,CAAC;MACxBK,OAAO,EAAER,SAAS,GAAG;IACzB,CAAC;;IAED;IACA,IAAI,CAAChB,QAAQ,CAACU,eAAe,CAACJ,cAAc,CAAC;;IAE7C;IACA,IAAI,CAACK,OAAO,CAACQ,SAAS,CAAC;EAC3B;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}