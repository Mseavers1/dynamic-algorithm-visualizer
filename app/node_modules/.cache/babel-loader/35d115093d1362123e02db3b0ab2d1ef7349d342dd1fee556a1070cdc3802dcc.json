{"ast":null,"code":"import { BinaryTree } from \"../structures/binary_tree\";\nexport class MinHeap {\n  constructor(isDynamicSize, animator) {\n    this.isDynamicSize = isDynamicSize;\n    this.tree = void 0;\n    this.animator = void 0;\n    this.tree = new BinaryTree();\n    this.animator = animator;\n  }\n  getRandomString(length) {\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (let i = 0; i < length; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n  generate_random(size, allowStrings = false, allowNumbers = false) {\n    // Check if both are false\n    if (!allowNumbers && !allowStrings) allowNumbers = true;\n\n    // Limit the size\n\n    let numElement = null;\n    let stringElement = \"\";\n\n    // Randomize\n    for (let i = 0; i < size; i++) {\n      if (allowNumbers) {\n        numElement = Math.random() * 1000;\n\n        // Round float to digit of X place\n\n        // Is number negative?\n      }\n      if (allowStrings) {\n        stringElement = this.getRandomString(5);\n      }\n\n      // If both are allowed, add only one\n      if (allowNumbers && allowStrings) {\n        let rand = Math.random();\n\n        // Add string\n        if (rand >= 0.5) {}\n        // Add number\n        else {}\n      }\n    }\n  }\n  insert(value) {\n    var _this$tree;\n    (_this$tree = this.tree) === null || _this$tree === void 0 ? void 0 : _this$tree.add(value);\n    const newInstruction = {\n      type: 'add',\n      value: value,\n      index: this.tree.length - 1\n    };\n\n    //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\n    this.animator.add_instruction(newInstruction);\n    this.heapify(this.tree.length);\n    this.animator.start_processing();\n\n    //alert(this.tree?.get_current_height())\n\n    //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\n  }\n  delete(value) {\n    var _this$tree2;\n    const i = this.tree.search(value);\n    if (i < 0) return;\n\n    // First Swap current and Last index\n    this.tree.swap(i + 1, this.tree.length);\n    let newInstruction = {\n      type: 'swap',\n      fromIndex: this.tree.length - 1,\n      toIndex: i\n    };\n    this.animator.add_instruction(newInstruction);\n    (_this$tree2 = this.tree) === null || _this$tree2 === void 0 ? void 0 : _this$tree2.remove(this.tree.length - 1);\n    newInstruction = {\n      type: 'remove',\n      index: this.tree.length\n    };\n    this.animator.add_instruction(newInstruction);\n    this.heapifyDown(i);\n    this.animator.start_processing();\n  }\n  heapify(cur_index) {\n    // At root, do not heapify.\n    if (cur_index == 1) return;\n\n    // Check if parent is less than the current index\n    const cur = this.tree.get(cur_index);\n    const par_index = this.tree.get_parent(cur_index);\n    const par_val = this.tree.get(par_index);\n    if (cur >= par_val) return;\n\n    // If so swap the indexes\n    this.tree.swap(cur_index, par_index);\n    const newInstruction = {\n      type: 'swap',\n      fromIndex: par_index - 1,\n      toIndex: cur_index - 1\n    };\n\n    //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\n    this.animator.add_instruction(newInstruction);\n\n    // Heapify on the new cur index\n    this.heapify(par_index);\n  }\n  heapifyDown(cur_index) {\n    const left = 2 * cur_index + 1;\n    const right = 2 * cur_index + 2;\n    const vals = this.tree.values;\n    const smallest = vals[left] > vals[right] ? right : left;\n    if (vals[smallest] < vals[cur_index]) {\n      this.tree.swap(cur_index, smallest);\n      const newInstruction = {\n        type: 'swap',\n        fromIndex: cur_index,\n        toIndex: smallest\n      };\n      this.animator.add_instruction(newInstruction);\n      this.heapifyDown(smallest);\n    }\n  }\n}","map":{"version":3,"names":["BinaryTree","MinHeap","constructor","isDynamicSize","animator","tree","getRandomString","length","chars","result","i","charAt","Math","floor","random","generate_random","size","allowStrings","allowNumbers","numElement","stringElement","rand","insert","value","_this$tree","add","newInstruction","type","index","add_instruction","heapify","start_processing","delete","_this$tree2","search","swap","fromIndex","toIndex","remove","heapifyDown","cur_index","cur","get","par_index","get_parent","par_val","left","right","vals","values","smallest"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/min_heap.tsx"],"sourcesContent":["import { Algorithm } from \"./algorithm_interface\";\r\nimport {BinaryTree} from \"../structures/binary_tree\";\r\n\r\nimport {Instruction} from \"./tree_intructions\";\r\nimport React from \"react\";\r\nimport {TreeAnimate} from \"../structures/tree_animator\";\r\n\r\nexport class MinHeap implements Algorithm {\r\n\r\n    private tree : BinaryTree;\r\n\r\n    private animator: TreeAnimate;\r\n\r\n    constructor(\r\n        private isDynamicSize: boolean,\r\n        animator: TreeAnimate,\r\n    ) {\r\n        this.tree = new BinaryTree();\r\n        this.animator = animator;\r\n    }\r\n\r\n    getRandomString(length: number): string {\r\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n        let result = \"\";\r\n        for (let i = 0; i < length; i++) {\r\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    generate_random(size: number, allowStrings: boolean = false, allowNumbers: boolean = false) {\r\n\r\n        // Check if both are false\r\n        if (!allowNumbers && !allowStrings) allowNumbers = true\r\n\r\n        // Limit the size\r\n\r\n        let numElement : number | null = null;\r\n        let stringElement : string = \"\";\r\n\r\n        // Randomize\r\n        for (let i = 0; i < size; i++) {\r\n\r\n            if (allowNumbers) {\r\n                numElement = Math.random() * 1000;\r\n\r\n                // Round float to digit of X place\r\n\r\n                // Is number negative?\r\n\r\n            }\r\n\r\n            if (allowStrings) {\r\n                stringElement = this.getRandomString(5);\r\n            }\r\n\r\n            // If both are allowed, add only one\r\n            if (allowNumbers && allowStrings) {\r\n\r\n                let rand = Math.random();\r\n\r\n                // Add string\r\n                if (rand >= 0.5) {\r\n\r\n\r\n\r\n                }\r\n                // Add number\r\n                else {\r\n\r\n                }\r\n\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    insert(value: string | number) : void {\r\n\r\n        this.tree?.add(value);\r\n\r\n        const newInstruction: Instruction = {\r\n            type: 'add',\r\n            value: value,\r\n            index: this.tree.length - 1,\r\n        };\r\n\r\n        //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\r\n        this.animator.add_instruction(newInstruction);\r\n\r\n        this.heapify(this.tree.length);\r\n\r\n        this.animator.start_processing()\r\n\r\n        //alert(this.tree?.get_current_height())\r\n\r\n        //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\r\n\r\n    }\r\n\r\n    delete(value: string | number) : void {\r\n\r\n        const i = this.tree.search(value);\r\n\r\n        if (i < 0) return;\r\n\r\n        // First Swap current and Last index\r\n        this.tree.swap(i + 1, this.tree.length);\r\n\r\n        let newInstruction: Instruction = {\r\n            type: 'swap',\r\n            fromIndex: this.tree.length - 1,\r\n            toIndex: i,\r\n        };\r\n\r\n        this.animator.add_instruction(newInstruction)\r\n\r\n        this.tree?.remove(this.tree.length - 1);\r\n\r\n        newInstruction = {\r\n            type: 'remove',\r\n            index: this.tree.length,\r\n        };\r\n\r\n        this.animator.add_instruction(newInstruction);\r\n\r\n        this.heapifyDown(i);\r\n\r\n        this.animator.start_processing();\r\n    }\r\n\r\n    heapify(cur_index : number): void {\r\n\r\n        // At root, do not heapify.\r\n        if (cur_index == 1) return;\r\n\r\n        // Check if parent is less than the current index\r\n        const cur = this.tree.get(cur_index);\r\n        const par_index = this.tree.get_parent(cur_index);\r\n        const par_val = this.tree.get(par_index);\r\n\r\n        if (cur >= par_val) return;\r\n\r\n        // If so swap the indexes\r\n        this.tree.swap(cur_index, par_index);\r\n\r\n        const newInstruction: Instruction = {\r\n            type: 'swap',\r\n            fromIndex: par_index - 1,\r\n            toIndex: cur_index - 1,\r\n        };\r\n\r\n        //this.setInstructions((prevInstructions) => [...prevInstructions, newInstruction]);\r\n        this.animator.add_instruction(newInstruction);\r\n\r\n        // Heapify on the new cur index\r\n        this.heapify(par_index);\r\n    }\r\n\r\n    heapifyDown(cur_index : number) : void {\r\n\r\n        const left: number = 2 * cur_index + 1;\r\n        const right: number = 2 * cur_index + 2;\r\n        const vals = this.tree.values;\r\n\r\n        const smallest = vals[left] > vals[right] ? right : left;\r\n\r\n        if (vals[smallest] < vals[cur_index]) {\r\n            this.tree.swap(cur_index, smallest);\r\n\r\n            const newInstruction: Instruction = {\r\n                type: 'swap',\r\n                fromIndex: cur_index,\r\n                toIndex: smallest,\r\n            };\r\n\r\n            this.animator.add_instruction(newInstruction);\r\n\r\n            this.heapifyDown(smallest);\r\n        }\r\n    }\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}