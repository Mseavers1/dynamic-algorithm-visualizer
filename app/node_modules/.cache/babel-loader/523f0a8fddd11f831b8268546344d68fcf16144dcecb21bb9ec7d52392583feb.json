{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Micha\\\\Documents\\\\GitHub\\\\dynamic-algorithm-visualizer\\\\app\\\\src\\\\components\\\\algorithms\\\\min_heap.tsx\",\n  _s = $RefreshSig$();\nimport { BinaryTree } from \"../structures/binary_tree\";\nimport { animated, useTransition } from \"@react-spring/web\";\nimport { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class MinHeap {\n  constructor(isDynamicSize) {\n    this.isDynamicSize = isDynamicSize;\n    this.tree = void 0;\n    this.tree = new BinaryTree();\n  }\n  insert(value) {\n    var _this$tree;\n    (_this$tree = this.tree) === null || _this$tree === void 0 ? void 0 : _this$tree.add(value);\n    this.heapify(this.tree.length);\n\n    //alert(this.tree?.get_current_height())\n\n    //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\n  }\n  delete(value) {}\n  render() {\n    //alert(this.current_max_height);\n\n    return /*#__PURE__*/_jsxDEV(\"svg\", {\n      width: \"500\",\n      height: \"500\",\n      children: /*#__PURE__*/_jsxDEV(AnimatedTree, {\n        values: this.tree.values,\n        height: 1\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 13\n    }, this);\n  }\n  heapify(cur_index) {\n    // At root, do not heapify.\n    if (cur_index == 1) return;\n\n    // Check if parent is less than the current index\n    const cur = this.tree.get(cur_index);\n    const par_index = this.tree.get_parent(cur_index);\n    const par_val = this.tree.get(par_index);\n    if (cur >= par_val) return;\n\n    // If so swap the indexes\n    this.tree.swap(cur_index, par_index);\n\n    // Heapify on the new cur index\n    this.heapify(par_index);\n  }\n}\nconst AnimatedTree = ({\n  values,\n  height\n}) => {\n  _s();\n  const [instructionStack, setInstructionStack] = useState([]); // Stack of instructions\n  const [currentValues, setCurrentValues] = useState(values); // Current values in the tree\n  const [positions, setPositions] = useState({});\n  const [currentInstruction, setCurrentInstruction] = useState();\n\n  // Simulate the stack of instructions (for testing purposes)\n  useEffect(() => {\n    const newInstructions = [{\n      type: 'add',\n      value: '1',\n      index: 0\n    }, {\n      type: 'add',\n      value: '2',\n      index: 1\n    }, {\n      type: 'add',\n      value: '0',\n      index: 2\n    }, {\n      type: 'swap',\n      fromIndex: 0,\n      toIndex: 2\n    }];\n    setInstructionStack(newInstructions);\n  }, []);\n\n  // Transition based on the current values and the instruction stack\n  const nodeTransitions = useTransition(currentValues.map((value, i) => ({\n    value,\n    index: i\n  })), {\n    keys: item => `${item.value}-${item.index}`,\n    from: {\n      opacity: 0,\n      transform: 'scale(0)'\n    },\n    enter: {\n      opacity: 1,\n      transform: 'scale(1)'\n    },\n    leave: {\n      opacity: 0,\n      transform: 'scale(0)'\n    },\n    initial: null,\n    trail: 300,\n    config: {\n      duration: 1000\n    }\n  });\n  const getNodePosition = index => {\n    if (index < 0 || isNaN(index)) return {\n      x: 0,\n      y: 0\n    };\n    if (index === 0) return {\n      x: 250,\n      y: 50\n    }; // Root at the center\n\n    const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\n    const xSpacing = 200 / (depth + 1); // Adjust x spacing\n    const ySpacing = 80; // Vertical spacing\n\n    const parentIndex = Math.floor((index - 1) / 2);\n    const parentPos = getNodePosition(parentIndex);\n    const isLeftChild = index % 2 === 1;\n    const xOffset = isLeftChild ? -xSpacing : xSpacing;\n    return {\n      x: parentPos.x + xOffset,\n      y: parentPos.y + ySpacing\n    };\n  };\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n  const processInstructions = async () => {\n    for (let instruction of instructionStack) {\n      setCurrentInstruction(instruction);\n\n      // Handle the \"add\" instruction\n      if (instruction.type === 'add' && typeof instruction.index === 'number') {\n        await new Promise(resolve => {\n          setCurrentValues(prev => {\n            const newValues = [...prev];\n            if (instruction.index != null && instruction.value != undefined) {\n              newValues.splice(instruction.index, 0, instruction.value);\n            }\n            resolve(); // Resolve after the update\n            return newValues;\n          });\n        });\n\n        // Add a 1-second delay before processing the next instruction\n        await delay(1000); // Delay for 1 second\n      }\n\n      // Handle the \"swap\" instruction\n      if (instruction.type === 'swap' && typeof instruction.fromIndex === 'number' && typeof instruction.toIndex === 'number') {\n        await new Promise(resolve => {\n          // Get the current positions of the two nodes to swap\n          const fromPos = getNodePosition(instruction.fromIndex);\n          const toPos = getNodePosition(instruction.toIndex);\n\n          // Animate the swap\n          setPositions(prev => ({\n            ...prev,\n            [instruction.fromIndex]: toPos,\n            [instruction.toIndex]: fromPos\n          }));\n\n          // Perform the swap on currentValues after the animation has time to run\n          setCurrentValues(prev => {\n            const newValues = [...prev];\n            [newValues[instruction.fromIndex], newValues[instruction.toIndex]] = [newValues[instruction.toIndex], newValues[instruction.fromIndex]];\n            resolve(); // Resolve after the swap\n            return newValues;\n          });\n        });\n\n        // Add a 1-second delay before processing the next instruction\n        await delay(1000); // Delay for 1 second\n      }\n    }\n  };\n  const nodePositions = index => {\n    return positions[index] || getNodePosition(index); // Use the swapped position or default position\n  };\n  const positionTransitions = useTransition(currentValues.map((value, i) => ({\n    value,\n    index: i\n  })), {\n    keys: item => `${item.value}-${item.index}`,\n    from: item => ({\n      x: nodePositions(item.index).x,\n      y: nodePositions(item.index).y\n    }),\n    enter: item => ({\n      x: getNodePosition(item.index).x,\n      y: getNodePosition(item.index).y\n    }),\n    leave: {\n      x: 0,\n      y: 0\n    },\n    config: {\n      duration: 500\n    }\n  });\n\n  // Ensure that state updates are processed in order by using this method within the useEffect\n  useEffect(() => {\n    const runInstructions = async () => {\n      await processInstructions(); // Ensure all instructions are processed sequentially\n    };\n    runInstructions();\n  }, [instructionStack]);\n  return /*#__PURE__*/_jsxDEV(\"g\", {\n    children: [nodeTransitions((style, {\n      value,\n      index\n    }) => {\n      if (index === 0) return null; // Root node has no parent, skip edge rendering\n      const {\n        x,\n        y\n      } = getNodePosition(index);\n      const parentIndex = Math.floor((index - 1) / 2);\n      const parentPos = getNodePosition(parentIndex);\n      return /*#__PURE__*/_jsxDEV(animated.line, {\n        // Separate key for lines\n        x1: parentPos.x,\n        y1: parentPos.y,\n        x2: x,\n        y2: y,\n        stroke: \"black\",\n        strokeWidth: \"2\",\n        style: {\n          strokeOpacity: 1\n        }\n      }, `line-${index}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 210,\n        columnNumber: 21\n      }, this);\n    }), (currentInstruction === null || currentInstruction === void 0 ? void 0 : currentInstruction.type) === 'swap' ? positionTransitions((style, {\n      value,\n      index\n    }) => {\n      const {\n        x,\n        y\n      } = style; // Animated position values\n\n      return /*#__PURE__*/_jsxDEV(animated.g, {\n        style: {\n          opacity: 1\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n          cx: x,\n          cy: y,\n          r: 30,\n          fill: \"steelblue\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 230,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n          x: x,\n          y: y,\n          dy: 5,\n          textAnchor: \"middle\",\n          fill: \"white\",\n          fontSize: \"12\",\n          children: value\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 231,\n          columnNumber: 29\n        }, this)]\n      }, `node-${index}`, true, {\n        fileName: _jsxFileName,\n        lineNumber: 229,\n        columnNumber: 25\n      }, this);\n    }) : nodeTransitions((style, {\n      value,\n      index\n    }) => {\n      const {\n        x,\n        y\n      } = nodePositions(index); // Use nodePositions instead of getNodePosition\n\n      return /*#__PURE__*/_jsxDEV(animated.g, {\n        style: style,\n        children: [/*#__PURE__*/_jsxDEV(\"circle\", {\n          cx: x,\n          cy: y,\n          r: 30,\n          fill: \"steelblue\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 243,\n          columnNumber: 29\n        }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n          x: x,\n          y: y,\n          dy: 5,\n          textAnchor: \"middle\",\n          fill: \"white\",\n          fontSize: \"12\",\n          children: value\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 244,\n          columnNumber: 29\n        }, this)]\n      }, `node-${index}`, true, {\n        fileName: _jsxFileName,\n        lineNumber: 242,\n        columnNumber: 25\n      }, this);\n    })]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 201,\n    columnNumber: 9\n  }, this);\n};\n_s(AnimatedTree, \"LatKb4KqNLa2+/55T3hlnsNJba8=\", false, function () {\n  return [useTransition, useTransition];\n});\n_c = AnimatedTree;\nvar _c;\n$RefreshReg$(_c, \"AnimatedTree\");","map":{"version":3,"names":["BinaryTree","animated","useTransition","useEffect","useState","jsxDEV","_jsxDEV","MinHeap","constructor","isDynamicSize","tree","insert","value","_this$tree","add","heapify","length","delete","render","width","height","children","AnimatedTree","values","fileName","_jsxFileName","lineNumber","columnNumber","cur_index","cur","get","par_index","get_parent","par_val","swap","_s","instructionStack","setInstructionStack","currentValues","setCurrentValues","positions","setPositions","currentInstruction","setCurrentInstruction","newInstructions","type","index","fromIndex","toIndex","nodeTransitions","map","i","keys","item","from","opacity","transform","enter","leave","initial","trail","config","duration","getNodePosition","isNaN","x","y","depth","Math","floor","log2","xSpacing","ySpacing","parentIndex","parentPos","isLeftChild","xOffset","delay","ms","Promise","resolve","setTimeout","processInstructions","instruction","prev","newValues","undefined","splice","fromPos","toPos","nodePositions","positionTransitions","runInstructions","style","line","x1","y1","x2","y2","stroke","strokeWidth","strokeOpacity","g","cx","cy","r","fill","dy","textAnchor","fontSize","_c","$RefreshReg$"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/min_heap.tsx"],"sourcesContent":["import { Algorithm } from \"./algorithm_interface\";\r\nimport {BinaryTree} from \"../structures/binary_tree\";\r\nimport {animated, useTransition} from \"@react-spring/web\";\r\nimport {useEffect, useState} from \"react\";\r\n\r\nexport class MinHeap implements Algorithm {\r\n\r\n    private tree : BinaryTree;\r\n\r\n    constructor(\r\n        private isDynamicSize: boolean\r\n    ) {\r\n       this.tree = new BinaryTree();\r\n    }\r\n\r\n    insert(value: string | number) : void {\r\n\r\n        this.tree?.add(value);\r\n\r\n        this.heapify(this.tree.length);\r\n\r\n        //alert(this.tree?.get_current_height())\r\n\r\n        //if (this.isDynamicSize && current_height > this.current_max_height) this.current_max_height = current_height + 1;\r\n\r\n    }\r\n\r\n    delete(value: string | number) : void {\r\n\r\n    }\r\n\r\n    render(): JSX.Element {\r\n\r\n        //alert(this.current_max_height);\r\n\r\n        return (\r\n            <svg width=\"500\" height=\"500\">\r\n                <AnimatedTree values={this.tree.values} height={1}/>\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    heapify(cur_index : number): void {\r\n\r\n        // At root, do not heapify.\r\n        if (cur_index == 1) return;\r\n\r\n        // Check if parent is less than the current index\r\n        const cur = this.tree.get(cur_index);\r\n        const par_index = this.tree.get_parent(cur_index);\r\n        const par_val = this.tree.get(par_index);\r\n\r\n        if (cur >= par_val) return;\r\n\r\n        // If so swap the indexes\r\n        this.tree.swap(cur_index, par_index);\r\n\r\n        // Heapify on the new cur index\r\n        this.heapify(par_index);\r\n    }\r\n}\r\n\r\ntype Instruction = {\r\n    type: 'add' | 'swap';\r\n    value?: string | number;\r\n    index?: number;\r\n    fromIndex?: number;\r\n    toIndex?: number;\r\n};\r\n\r\nconst AnimatedTree = ({ values, height }: { values: (string | number)[], height: number }) => {\r\n    const [instructionStack, setInstructionStack] = useState<Instruction[]>([]); // Stack of instructions\r\n    const [currentValues, setCurrentValues] = useState(values); // Current values in the tree\r\n    const [positions, setPositions] = useState<{ [key: number]: { x: number; y: number } }>({});\r\n\r\n    const [currentInstruction, setCurrentInstruction] = useState<Instruction>();\r\n\r\n    // Simulate the stack of instructions (for testing purposes)\r\n    useEffect(() => {\r\n        const newInstructions: Instruction[] = [\r\n            { type: 'add', value: '1', index: 0 },\r\n            { type: 'add', value: '2', index: 1 },\r\n            { type: 'add', value: '0', index: 2 },\r\n            { type: 'swap', fromIndex: 0, toIndex: 2 },\r\n        ];\r\n        setInstructionStack(newInstructions);\r\n    }, []);\r\n\r\n    // Transition based on the current values and the instruction stack\r\n    const nodeTransitions = useTransition(currentValues.map((value, i) => ({ value, index: i })), {\r\n        keys: (item) => `${item.value}-${item.index}`,\r\n        from: { opacity: 0, transform: 'scale(0)' },\r\n        enter: { opacity: 1, transform: 'scale(1)' },\r\n        leave: { opacity: 0, transform: 'scale(0)' },\r\n        initial: null,\r\n        trail: 300,\r\n        config: { duration: 1000 },\r\n    });\r\n\r\n    const getNodePosition = (index: number): { x: number, y: number } => {\r\n        if (index < 0 || isNaN(index)) return { x: 0, y: 0 };\r\n        if (index === 0) return { x: 250, y: 50 }; // Root at the center\r\n\r\n        const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\r\n        const xSpacing = (200) / (depth + 1); // Adjust x spacing\r\n        const ySpacing = 80; // Vertical spacing\r\n\r\n        const parentIndex = Math.floor((index - 1) / 2);\r\n        const parentPos = getNodePosition(parentIndex);\r\n\r\n        const isLeftChild = index % 2 === 1;\r\n        const xOffset = isLeftChild ? -xSpacing : xSpacing;\r\n\r\n        return { x: parentPos.x + xOffset, y: parentPos.y + ySpacing };\r\n    };\r\n\r\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n    const processInstructions = async () => {\r\n        for (let instruction of instructionStack) {\r\n\r\n            setCurrentInstruction(instruction);\r\n\r\n            // Handle the \"add\" instruction\r\n            if (instruction.type === 'add' && typeof instruction.index === 'number') {\r\n                await new Promise<void>((resolve) => {\r\n                    setCurrentValues((prev) => {\r\n                        const newValues = [...prev];\r\n                        if (instruction.index != null && instruction.value != undefined) {\r\n                            newValues.splice(instruction.index, 0, instruction.value);\r\n                        }\r\n                        resolve(); // Resolve after the update\r\n                        return newValues;\r\n                    });\r\n                });\r\n\r\n                // Add a 1-second delay before processing the next instruction\r\n                await delay(1000); // Delay for 1 second\r\n            }\r\n\r\n            // Handle the \"swap\" instruction\r\n            if (instruction.type === 'swap' && typeof instruction.fromIndex === 'number' && typeof instruction.toIndex === 'number') {\r\n                await new Promise<void>((resolve) => {\r\n                    // Get the current positions of the two nodes to swap\r\n                    const fromPos = getNodePosition(instruction.fromIndex as number);\r\n                    const toPos = getNodePosition(instruction.toIndex as number);\r\n\r\n                    // Animate the swap\r\n                    setPositions((prev) => ({\r\n                        ...prev,\r\n                        [instruction.fromIndex as number]: toPos,\r\n                        [instruction.toIndex as number]: fromPos,\r\n                    }));\r\n\r\n                    // Perform the swap on currentValues after the animation has time to run\r\n                    setCurrentValues((prev) => {\r\n                        const newValues = [...prev];\r\n                        [newValues[instruction.fromIndex as number], newValues[instruction.toIndex as number]] = [\r\n                            newValues[instruction.toIndex as number],\r\n                            newValues[instruction.fromIndex as number],\r\n                        ];\r\n                        resolve(); // Resolve after the swap\r\n                        return newValues;\r\n                    });\r\n                });\r\n\r\n                // Add a 1-second delay before processing the next instruction\r\n                await delay(1000); // Delay for 1 second\r\n            }\r\n        }\r\n    };\r\n\r\n    const nodePositions = (index: number) => {\r\n        return positions[index] || getNodePosition(index); // Use the swapped position or default position\r\n    };\r\n\r\n    const positionTransitions = useTransition(currentValues.map((value, i) => ({ value, index: i })), {\r\n        keys: (item) => `${item.value}-${item.index}`,\r\n        from: (item) => ({\r\n            x: nodePositions(item.index).x,\r\n            y: nodePositions(item.index).y,\r\n        }),\r\n        enter: (item) => ({\r\n            x: getNodePosition(item.index).x,\r\n            y: getNodePosition(item.index).y,\r\n        }),\r\n        leave: { x: 0, y: 0 },\r\n        config: { duration: 500 },\r\n    });\r\n\r\n    // Ensure that state updates are processed in order by using this method within the useEffect\r\n    useEffect(() => {\r\n        const runInstructions = async () => {\r\n            await processInstructions(); // Ensure all instructions are processed sequentially\r\n        };\r\n\r\n        runInstructions();\r\n    }, [instructionStack]);\r\n\r\n    return (\r\n        <g>\r\n            {/* Render edges (lines) first */}\r\n            {nodeTransitions((style, { value, index }) => {\r\n                if (index === 0) return null; // Root node has no parent, skip edge rendering\r\n                const { x, y } = getNodePosition(index);\r\n                const parentIndex = Math.floor((index - 1) / 2);\r\n                const parentPos = getNodePosition(parentIndex);\r\n\r\n                return (\r\n                    <animated.line\r\n                        key={`line-${index}`} // Separate key for lines\r\n                        x1={parentPos.x}\r\n                        y1={parentPos.y}\r\n                        x2={x}\r\n                        y2={y}\r\n                        stroke=\"black\"\r\n                        strokeWidth=\"2\"\r\n                        style={{ strokeOpacity: 1 }}\r\n                    />\r\n                );\r\n            })}\r\n\r\n            {/* Render nodes (circles) on top of the lines */}\r\n            {currentInstruction?.type === 'swap' ? (\r\n                positionTransitions((style, { value, index }) => {\r\n                    const { x, y } = style; // Animated position values\r\n\r\n                    return (\r\n                        <animated.g key={`node-${index}`} style={{ opacity: 1 }}>\r\n                            <circle cx={x} cy={y} r={30} fill=\"steelblue\" />\r\n                            <text x={x} y={y} dy={5} textAnchor=\"middle\" fill=\"white\" fontSize=\"12\">\r\n                                {value}\r\n                            </text>\r\n                        </animated.g>\r\n                    );\r\n                })\r\n            ) : (\r\n                nodeTransitions((style, { value, index }) => {\r\n                    const { x, y } = nodePositions(index); // Use nodePositions instead of getNodePosition\r\n\r\n                    return (\r\n                        <animated.g key={`node-${index}`} style={style}>\r\n                            <circle cx={x} cy={y} r={30} fill=\"steelblue\" />\r\n                            <text x={x} y={y} dy={5} textAnchor=\"middle\" fill=\"white\" fontSize=\"12\">\r\n                                {value}\r\n                            </text>\r\n                        </animated.g>\r\n                    );\r\n                })\r\n            )}\r\n        </g>\r\n    );\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}