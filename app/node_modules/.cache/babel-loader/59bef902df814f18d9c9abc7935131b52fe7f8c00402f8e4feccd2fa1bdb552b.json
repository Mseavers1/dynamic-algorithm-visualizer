{"ast":null,"code":"import { Node } from \"../pictures/node\";\nexport class TreeAddAllInstruction {\n  constructor(elements, nodes) {\n    this.elements = void 0;\n    this.nodes = void 0;\n    this.getNodePosition = index => {\n      if (index < 0 || isNaN(index)) return {\n        x: 0,\n        y: 0\n      };\n      if (index === 0) return {\n        x: 250,\n        y: 50\n      }; // Root at the center\n\n      const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\n      const xSpacing = 200 / (depth + 1); // Adjust x spacing\n      const ySpacing = 80; // Vertical spacing\n\n      const parentIndex = Math.floor((index - 1) / 2);\n      const parentPos = this.getNodePosition(parentIndex);\n      const isLeftChild = index % 2 === 1;\n      const xOffset = isLeftChild ? -xSpacing : xSpacing;\n      return {\n        x: parentPos.x + xOffset,\n        y: parentPos.y + ySpacing\n      };\n    };\n    this.nodes = nodes;\n    this.elements = elements;\n  }\n  async process(svg) {\n    let currentIndex = 0;\n    let transitions = [];\n    for (const element of this.elements) {\n      const position = this.getNodePosition(currentIndex);\n      const parentIndex = Math.floor((currentIndex - 1) / 2);\n      const hasParent = parentIndex >= 0;\n      let nodesGroup = svg.select(\"g.nodes\");\n      let edgesGroup = svg.select(\"g.edges\");\n      if (edgesGroup.empty()) {\n        edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\n      }\n      if (nodesGroup.empty()) {\n        nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\n      }\n      let edge = null;\n      if (hasParent) {\n        const parentPos = this.getNodePosition(parentIndex);\n        edge = edgesGroup.append(\"line\").attr(\"x1\", parentPos.x).attr(\"y1\", parentPos.y).attr(\"x2\", 200).attr(\"y2\", 200).attr(\"stroke\", \"black\").attr(\"stroke-width\", 5).style(\"opacity\", 0);\n      }\n\n      // Creates the circle node on screen\n      const nodeElement = nodesGroup.append(\"circle\").attr(\"cx\", 200).attr(\"cy\", 200).attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0);\n\n      // Creates the text label on screen\n      const label = nodesGroup.append(\"text\").attr(\"x\", 200).attr(\"y\", 200).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"white\").style(\"font-size\", \"12px\").text(element);\n      const nodeTransition = nodeElement.transition().duration(1000).style(\"opacity\", 1).attr(\"cx\", position.x).attr(\"cy\", position.y);\n      const labelTransition = label.transition().duration(1000).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y);\n      if (edge) {\n        const edgeTransition = edge.transition().duration(1000).style(\"opacity\", 1).attr(\"x2\", position.x).attr(\"y2\", position.y);\n        transitions.push(edgeTransition.end());\n      }\n      this.nodes.push(new Node(element, currentIndex, nodeElement, edge, label));\n      transitions.push(nodeTransition.end(), labelTransition.end());\n      currentIndex += 1;\n    }\n    await Promise.all(transitions);\n    alert(this.nodes);\n  }\n}","map":{"version":3,"names":["Node","TreeAddAllInstruction","constructor","elements","nodes","getNodePosition","index","isNaN","x","y","depth","Math","floor","log2","xSpacing","ySpacing","parentIndex","parentPos","isLeftChild","xOffset","process","svg","currentIndex","transitions","element","position","hasParent","nodesGroup","select","edgesGroup","empty","append","attr","edge","style","nodeElement","label","text","nodeTransition","transition","duration","labelTransition","edgeTransition","push","end","Promise","all","alert"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/tree_add_all_instruction.tsx"],"sourcesContent":["import {Node} from \"../pictures/node\";\r\nimport {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport * as d3 from \"d3\";\r\n\r\nexport class TreeAddAllInstruction implements Instruction {\r\n\r\n    elements: (string | number)[];\r\n    nodes: Node[];\r\n\r\n    constructor(elements: (string | number)[], nodes: Node[]) {\r\n        this.nodes = nodes;\r\n        this.elements = elements;\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n\r\n        let currentIndex = 0;\r\n        let transitions = [];\r\n\r\n        for (const element of this.elements) {\r\n\r\n            const position = this.getNodePosition(currentIndex);\r\n            const parentIndex = Math.floor((currentIndex - 1) / 2);\r\n            const hasParent = parentIndex >= 0;\r\n\r\n            let nodesGroup = svg.select<SVGGElement>(\"g.nodes\");\r\n            let edgesGroup = svg.select<SVGGElement>(\"g.edges\");\r\n\r\n            if (edgesGroup.empty()) {\r\n                edgesGroup = svg.append(\"g\").attr(\"class\", \"edges\");\r\n            }\r\n\r\n            if (nodesGroup.empty()) {\r\n                nodesGroup = svg.append(\"g\").attr(\"class\", \"nodes\");\r\n            }\r\n\r\n            let edge: d3.Selection<SVGLineElement, unknown, HTMLElement, any> | null = null;\r\n\r\n            if (hasParent) {\r\n                const parentPos = this.getNodePosition(parentIndex as number);\r\n                edge = edgesGroup.append(\"line\")\r\n                    .attr(\"x1\", parentPos.x)\r\n                    .attr(\"y1\", parentPos.y)\r\n                    .attr(\"x2\", 200)\r\n                    .attr(\"y2\", 200)\r\n                    .attr(\"stroke\", \"black\")\r\n                    .attr(\"stroke-width\", 5)\r\n                    .style(\"opacity\", 0);\r\n            }\r\n\r\n            // Creates the circle node on screen\r\n            const nodeElement = nodesGroup.append(\"circle\")\r\n                .attr(\"cx\", 200)\r\n                .attr(\"cy\", 200)\r\n                .attr(\"r\", 20)\r\n                .attr(\"class\", \"node\")\r\n                .style(\"opacity\", 0);\r\n\r\n            // Creates the text label on screen\r\n            const label = nodesGroup.append(\"text\")\r\n                .attr(\"x\", 200)\r\n                .attr(\"y\", 200)\r\n                .attr(\"class\", \"label\")\r\n                .attr(\"text-anchor\", \"middle\")\r\n                .attr(\"alignment-baseline\", \"middle\")\r\n                .style(\"fill\", \"white\")\r\n                .style(\"font-size\", \"12px\")\r\n                .text(element);\r\n\r\n            const nodeTransition = nodeElement.transition()\r\n                .duration(1000)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y)\r\n\r\n            const labelTransition = label.transition()\r\n                .duration(1000)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y)\r\n\r\n            if (edge) {\r\n                const edgeTransition = edge.transition()\r\n                    .duration(1000)\r\n                    .style(\"opacity\", 1)\r\n                    .attr(\"x2\", position.x)\r\n                    .attr(\"y2\", position.y);\r\n\r\n                transitions.push(edgeTransition.end());\r\n            }\r\n\r\n            this.nodes.push(new Node(element, currentIndex, nodeElement, edge, label))\r\n            transitions.push(nodeTransition.end(), labelTransition.end());\r\n\r\n            currentIndex += 1;\r\n        }\r\n\r\n        await Promise.all(transitions);\r\n        alert(this.nodes)\r\n    }\r\n\r\n    getNodePosition = (index: number): { x: number, y: number } => {\r\n        if (index < 0 || isNaN(index)) return { x: 0, y: 0 };\r\n        if (index === 0) return { x: 250, y: 50 }; // Root at the center\r\n\r\n        const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\r\n        const xSpacing = (200) / (depth + 1); // Adjust x spacing\r\n        const ySpacing = 80; // Vertical spacing\r\n\r\n        const parentIndex = Math.floor((index - 1) / 2);\r\n        const parentPos = this.getNodePosition(parentIndex);\r\n\r\n        const isLeftChild = index % 2 === 1;\r\n        const xOffset = isLeftChild ? -xSpacing : xSpacing;\r\n\r\n        return { x: parentPos.x + xOffset, y: parentPos.y + ySpacing };\r\n    };\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}