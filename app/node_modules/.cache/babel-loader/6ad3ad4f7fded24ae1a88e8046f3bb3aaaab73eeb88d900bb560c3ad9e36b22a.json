{"ast":null,"code":"export class BinaryTree{constructor(){this.values=[];this.length=0;}clear(){this.values=[];this.length=0;}get_parent(nodeID){if(!Number.isInteger(nodeID))throw new Error(\"NodeID must be an integer.\");if(this.length<=0||nodeID<=0)return-1;return Math.floor((nodeID-1)/2);}get_current_height(){return this.length>0?Math.floor(Math.log2(this.length)):0;}is_empty(){return!this.length;}add(value){this.values.push(value);this.length++;}search(value){// Convert value to a number if it's a string that can be converted\nconst parsedValue=typeof value==='string'?parseFloat(value):value;for(let i=0;i<this.length;i++){const currentValue=this.values[i];// If current value is a string that can be converted to a number, convert it\nconst parsedCurrentValue=typeof currentValue==='string'?parseFloat(currentValue):currentValue;// Compare the parsed values\nif(parsedCurrentValue===parsedValue)return i;if(parsedCurrentValue>parsedValue)return-1;}return-1;}remove(){let index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(this.length<=0)throw new Error(\"Cannot remove from an empty tree.\");if(index!=null&&index>=this.length)throw new Error(\"Index out of range.\");this.length--;if(index==null)return this.values.pop();const val=this.values[index];this.values.splice(index,1);return val;}swap(nodeA,nodeB){const a=this.values[nodeA];this.values[nodeA]=this.values[nodeB];this.values[nodeB]=a;}size(){return this.length;}get(nodeID){if(!Number.isInteger(nodeID))throw new Error(\"NodeID must be an integer.\");if(nodeID>=this.length||nodeID<0)throw new Error(\"NodeID (\"+nodeID.toString()+\") not within range.\");return this.values[nodeID];}}","map":{"version":3,"names":["BinaryTree","constructor","values","length","clear","get_parent","nodeID","Number","isInteger","Error","Math","floor","get_current_height","log2","is_empty","add","value","push","search","parsedValue","parseFloat","i","currentValue","parsedCurrentValue","remove","index","arguments","undefined","pop","val","splice","swap","nodeA","nodeB","a","size","get","toString"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/structures/binary_tree.tsx"],"sourcesContent":["import {ITree} from \"./ITree\";\r\nimport {IData} from \"./IData\";\r\n\r\nexport class BinaryTree implements ITree, IData {\r\n    values: (string | number)[] = [];\r\n    length: number = 0;\r\n\r\n    clear(): void {\r\n        this.values = [];\r\n        this.length = 0;\r\n    }\r\n\r\n    get_parent(nodeID: number): number {\r\n        if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\r\n        if (this.length <= 0 || nodeID <= 0) return -1;\r\n        return Math.floor((nodeID - 1) / 2);\r\n    }\r\n\r\n    get_current_height(): number {\r\n        return this.length > 0 ? Math.floor(Math.log2(this.length)) : 0;\r\n    }\r\n\r\n    is_empty(): boolean {\r\n        return !this.length;\r\n    }\r\n\r\n    add(value: string | number): void {\r\n        this.values.push(value);\r\n        this.length++;\r\n    }\r\n\r\n    search(value: string | number): number {\r\n        // Convert value to a number if it's a string that can be converted\r\n        const parsedValue = typeof value === 'string' ? parseFloat(value) : value;\r\n\r\n        for (let i = 0; i < this.length; i++) {\r\n            const currentValue = this.values[i];\r\n\r\n            // If current value is a string that can be converted to a number, convert it\r\n            const parsedCurrentValue = typeof currentValue === 'string' ? parseFloat(currentValue) : currentValue;\r\n\r\n            // Compare the parsed values\r\n            if (parsedCurrentValue === parsedValue) return i;\r\n            if (parsedCurrentValue > parsedValue) return -1;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n\r\n    remove(index: number | null = null): string | number {\r\n        if (this.length <= 0) throw new Error(\"Cannot remove from an empty tree.\");\r\n        if (index != null && index >= this.length) throw new Error(\"Index out of range.\");\r\n        this.length--;\r\n        if (index == null) return this.values.pop() as string | number;\r\n        const val = this.values[index];\r\n        this.values.splice(index, 1);\r\n        return val;\r\n    }\r\n\r\n    swap(nodeA: number, nodeB: number): void {\r\n        const a = this.values[nodeA];\r\n        this.values[nodeA] = this.values[nodeB];\r\n        this.values[nodeB] = a;\r\n    }\r\n\r\n    size(): number {\r\n        return this.length;\r\n    }\r\n\r\n    get(nodeID: number): number | string {\r\n        if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\r\n        if (nodeID >= this.length || nodeID < 0) throw new Error(\"NodeID (\" + nodeID.toString() + \") not within range.\");\r\n        return this.values[nodeID];\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}