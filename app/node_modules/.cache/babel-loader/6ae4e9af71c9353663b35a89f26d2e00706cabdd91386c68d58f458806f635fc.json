{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nimport * as d3 from \"d3\";\nexport const Testing = () => {\n  _s();\n  const [instructionStack, setInstructionStack] = useState([]);\n  useEffect(() => {\n    const newInstructions = [{\n      type: 'add',\n      value: '1',\n      index: 0\n    }, {\n      type: 'add',\n      value: '2',\n      index: 1\n    }, {\n      type: 'add',\n      value: '3',\n      index: 2\n    }];\n    setInstructionStack(newInstructions);\n  }, []);\n  const processInstructions = svg => {\n    instructionStack.forEach(instruction => {\n      if (instruction.type === 'add' && instruction.value) {\n        // Add a new node for 'add' instruction\n        const nodeElement = node(svg);\n\n        // Animate the node: fade in and move\n        nodeElement.transition().duration(1000) // Duration of 1 second\n        .style(\"opacity\", 1) // Fade in the node\n        .attr(\"cx\", 100 + (instruction.index || 0) * 50) // Place based on index, space out the nodes\n        .attr(\"cy\", 100); // Keep y position constant for simplicity\n      }\n    });\n  };\n\n  // Node function that appends a circle and returns the D3 selection\n  const node = svg => {\n    return svg.append(\"circle\") // Return the D3 selection after appending\n    .attr(\"cx\", 200).attr(\"cy\", 200).attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0); // Start invisible\n  };\n  useEffect(() => {\n    // Select the SVG element that the D3 code will operate on\n    const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\n\n    // Create and animate the first node (circle) using the node function\n    const node1 = node(svg);\n    node1.transition().duration(1000) // Duration of 1 second\n    .style(\"opacity\", 1) // Fade in the node\n    .attr(\"cx\", 300) // Move the node to (300, 100)\n    .attr(\"cy\", 100);\n\n    // Create and animate the second node (circle) using the node function\n    const node2 = node(svg);\n    node2.transition().duration(1000) // Duration of 1 second\n    .style(\"opacity\", 1) // Fade in the node\n    .attr(\"cx\", 400) // Move the node to (400, 200)\n    .attr(\"cy\", 200);\n  }, []); // Empty dependency array to run the effect only once\n\n  return null; // No need to return an element here, as we're using D3 to manipulate the SVG\n};\n_s(Testing, \"TFYHpKeMWd12HTpksPsVMW+UKFk=\");\n_c = Testing;\nvar _c;\n$RefreshReg$(_c, \"Testing\");","map":{"version":3,"names":["useEffect","useState","d3","Testing","_s","instructionStack","setInstructionStack","newInstructions","type","value","index","processInstructions","svg","forEach","instruction","nodeElement","node","transition","duration","style","attr","append","select","node1","node2","_c","$RefreshReg$"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/algorithms/animation_testing.tsx"],"sourcesContent":["import React, {useEffect, useState} from \"react\";\r\nimport * as d3 from \"d3\";\r\nimport {BaseType} from \"d3\";\r\n\r\nexport const Testing: React.FC = () => {\r\n\r\n    const [instructionStack, setInstructionStack] = useState<Instruction[]>([]);\r\n\r\n    type Instruction = {\r\n        type: 'add' | 'swap';\r\n        value?: string | number;\r\n        index?: number;\r\n        fromIndex?: number;\r\n        toIndex?: number;\r\n    };\r\n\r\n    useEffect(() => {\r\n        const newInstructions: Instruction[] = [\r\n            { type: 'add', value: '1', index: 0 },\r\n            { type: 'add', value: '2', index: 1 },\r\n            { type: 'add', value: '3', index: 2 },\r\n        ];\r\n        setInstructionStack(newInstructions);\r\n    }, []);\r\n\r\n    const processInstructions = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>) => {\r\n        instructionStack.forEach((instruction) => {\r\n            if (instruction.type === 'add' && instruction.value) {\r\n                // Add a new node for 'add' instruction\r\n                const nodeElement = node(svg);\r\n\r\n                // Animate the node: fade in and move\r\n                nodeElement.transition()\r\n                    .duration(1000)  // Duration of 1 second\r\n                    .style(\"opacity\", 1)  // Fade in the node\r\n                    .attr(\"cx\", 100 + (instruction.index || 0) * 50)  // Place based on index, space out the nodes\r\n                    .attr(\"cy\", 100);  // Keep y position constant for simplicity\r\n            }\r\n        });\r\n    };\r\n\r\n    // Node function that appends a circle and returns the D3 selection\r\n    const node = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>) => {\r\n        return svg.append(\"circle\")  // Return the D3 selection after appending\r\n            .attr(\"cx\", 200)\r\n            .attr(\"cy\", 200)\r\n            .attr(\"r\", 20)\r\n            .attr(\"class\", \"node\")\r\n            .style(\"opacity\", 0);  // Start invisible\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Select the SVG element that the D3 code will operate on\r\n        const svg = d3.select(\"#svg-container\")\r\n            .attr(\"width\", 500)\r\n            .attr(\"height\", 500);\r\n\r\n        // Create and animate the first node (circle) using the node function\r\n        const node1 = node(svg);\r\n\r\n        node1.transition()\r\n            .duration(1000)  // Duration of 1 second\r\n            .style(\"opacity\", 1)  // Fade in the node\r\n            .attr(\"cx\", 300)  // Move the node to (300, 100)\r\n            .attr(\"cy\", 100);\r\n\r\n        // Create and animate the second node (circle) using the node function\r\n        const node2 = node(svg);\r\n\r\n        node2.transition()\r\n            .duration(1000)  // Duration of 1 second\r\n            .style(\"opacity\", 1)  // Fade in the node\r\n            .attr(\"cx\", 400)  // Move the node to (400, 200)\r\n            .attr(\"cy\", 200);\r\n    }, []);  // Empty dependency array to run the effect only once\r\n\r\n    return null;  // No need to return an element here, as we're using D3 to manipulate the SVG\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}