{"ast":null,"code":"export class FAAddAllInstruction {\n  constructor(graph) {\n    this.graph = void 0;\n    this.graph = graph;\n  }\n  async process(svg) {\n    const nodeTransitions = [];\n    const labelTransitions = [];\n    const nodesGroup = svg.append(\"g\");\n    let indexNodes = new Map();\n    let index = 0;\n    const total = this.graph.get_nodes().size;\n\n    // Draw all nodes\n    this.graph.get_nodes().forEach((node, value) => {\n      const pos = this.getPosition(index, total, 350, 200);\n      const current_node = this.createNode(nodesGroup, pos.x, pos.y);\n      const label = this.createLabel(nodesGroup, pos, value);\n      const node_transition = this.applyNodeTransition(current_node, pos);\n      const label_transition = this.applyLabelTransition(label, pos);\n      indexNodes.set(value, [index++, current_node]);\n      nodeTransitions.push(node_transition);\n      labelTransitions.push(label_transition);\n    });\n\n    // Draw connectors\n    this.graph.get_nodes().forEach((node, value) => {});\n    await Promise.all([...nodeTransitions, ...labelTransitions]);\n  }\n  createLine(svgGroup, start, end, strokeColor = \"black\", strokeWidth = 2, opacity = 1) {\n    return svgGroup.append(\"line\").attr(\"x1\", start.x).attr(\"y1\", start.y).attr(\"x2\", end.x).attr(\"y2\", end.y).attr(\"stroke\", strokeColor).attr(\"stroke-width\", strokeWidth).style(\"opacity\", opacity);\n  }\n  createLabel(nodesGroup, position, txt) {\n    return nodesGroup.append(\"text\").attr(\"x\", position.x).attr(\"y\", position.y).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"black\").style(\"font-size\", \"20px\").text(txt);\n  }\n  createNode(nodesGroup, cx, cy, r = 20, className = \"node\", opacity = 0) {\n    return nodesGroup.append(\"circle\").attr(\"cx\", cx).attr(\"cy\", cy).attr(\"r\", r).attr(\"class\", className).style(\"opacity\", opacity);\n  }\n  applyNodeTransition(node, position, duration = 1000) {\n    return new Promise(resolve => {\n      node.transition().duration(duration).attr(\"cx\", position.x).attr(\"cy\", position.y).style(\"opacity\", 1).attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"fill\", \"white\").on(\"end\", () => resolve());\n    });\n  }\n  applyLabelTransition(label, position, duration = 1000) {\n    return new Promise(resolve => {\n      label.transition().duration(duration).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y).on(\"end\", () => resolve());\n    });\n  }\n\n  // Gets the position in a shaped form\n  getPosition(index, numberOfNodes, centerX, centerY, radius = 100) {\n    const angle = 2 * Math.PI * index / numberOfNodes;\n\n    // Calculate x and y coordinates using polar to Cartesian conversion\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return {\n      x: x + centerX,\n      y: y + centerY\n    };\n  }\n}","map":{"version":3,"names":["FAAddAllInstruction","constructor","graph","process","svg","nodeTransitions","labelTransitions","nodesGroup","append","indexNodes","Map","index","total","get_nodes","size","forEach","node","value","pos","getPosition","current_node","createNode","x","y","label","createLabel","node_transition","applyNodeTransition","label_transition","applyLabelTransition","set","push","Promise","all","createLine","svgGroup","start","end","strokeColor","strokeWidth","opacity","attr","style","position","txt","text","cx","cy","r","className","duration","resolve","transition","on","numberOfNodes","centerX","centerY","radius","angle","Math","PI","cos","sin"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_all_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\n\r\nexport class FAAddAllInstruction implements Instruction {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    constructor(graph: FA_Graph) {\r\n        this.graph = graph;\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n        const nodeTransitions: Promise<void>[] = [];\r\n        const labelTransitions: Promise<void>[] = [];\r\n\r\n        const nodesGroup = (svg.append(\"g\") as unknown) as Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        let indexNodes: Map<string | number, [number, d3.Selection<SVGCircleElement, unknown, null, undefined>]> = new Map();\r\n        let index = 0;\r\n        const total = this.graph.get_nodes().size;\r\n\r\n        // Draw all nodes\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            const pos = this.getPosition(index, total, 350, 200);\r\n            const current_node = this.createNode(nodesGroup, pos.x, pos.y);\r\n            const label = this.createLabel(nodesGroup, pos, value as string)\r\n            const node_transition = this.applyNodeTransition(current_node, pos);\r\n            const label_transition = this.applyLabelTransition(label, pos);\r\n\r\n            indexNodes.set(value, [index++, current_node]);\r\n            nodeTransitions.push(node_transition);\r\n            labelTransitions.push(label_transition);\r\n        });\r\n\r\n        // Draw connectors\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            \r\n        });\r\n\r\n\r\n\r\n\r\n        await Promise.all([...nodeTransitions, ...labelTransitions]);\r\n    }\r\n\r\n    createLine(\r\n        svgGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        start: { x: number; y: number },\r\n        end: { x: number; y: number },\r\n        strokeColor: string = \"black\",\r\n        strokeWidth: number = 2,\r\n        opacity: number = 1\r\n    ): d3.Selection<SVGLineElement, unknown, null, undefined> {\r\n        return svgGroup.append(\"line\")\r\n            .attr(\"x1\", start.x)\r\n            .attr(\"y1\", start.y)\r\n            .attr(\"x2\", end.x)\r\n            .attr(\"y2\", end.y)\r\n            .attr(\"stroke\", strokeColor)\r\n            .attr(\"stroke-width\", strokeWidth)\r\n            .style(\"opacity\", opacity);\r\n    }\r\n\r\n\r\n    createLabel(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, position: { x: number, y: number }, txt: string): d3.Selection<SVGTextElement, unknown, null, undefined> {\r\n        return nodesGroup.append(\"text\")\r\n            .attr(\"x\", position.x)\r\n            .attr(\"y\", position.y)\r\n            .attr(\"class\", \"label\")\r\n            .attr(\"text-anchor\", \"middle\")\r\n            .attr(\"alignment-baseline\", \"middle\")\r\n            .style(\"fill\", \"black\")\r\n            .style(\"font-size\", \"20px\")\r\n            .text(txt);\r\n    }\r\n\r\n\r\n    createNode(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, cx: number, cy: number, r: number = 20,\r\n                                        className: string = \"node\", opacity: number = 0\r\n    ): d3.Selection<SVGCircleElement, unknown, null, undefined> {\r\n\r\n        return nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", cx)\r\n            .attr(\"cy\", cy)\r\n            .attr(\"r\", r)\r\n            .attr(\"class\", className)\r\n            .style(\"opacity\", opacity);\r\n    }\r\n\r\n    applyNodeTransition(\r\n        node: d3.Selection<SVGCircleElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            node.transition()\r\n                .duration(duration)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"white\")\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n    applyLabelTransition(\r\n        label: d3.Selection<SVGTextElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            label.transition()\r\n                .duration(duration)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y)\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n\r\n    // Gets the position in a shaped form\r\n    getPosition(index: number, numberOfNodes: number, centerX: number, centerY: number, radius: number = 100) {\r\n        const angle = (2 * Math.PI * index) / numberOfNodes;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}