{"ast":null,"code":"// Counter to generate unique IDs for curved paths\nlet pathIdCounter = 0;\nexport class FAAddAllInstruction {\n  constructor(graph) {\n    this.graph = void 0;\n    this.graph = graph;\n  }\n  async process(svg) {\n    const nodeTransitions = [];\n    const labelTransitions = [];\n    // Ensure the 'lines' group is added first so lines are behind nodes and labels\n    const linesGroup = svg.append(\"g\").attr(\"id\", \"lines\");\n    const nodesGroup = svg.append(\"g\");\n    let indexNodes = new Map();\n    let index = 0;\n    const total = this.graph.get_nodes().size;\n\n    // Draw all nodes\n    this.graph.get_nodes().forEach((node, value) => {\n      const pos = this.getPosition(index, total, 350, 200);\n      const current_node = this.createNode(nodesGroup, pos.x, pos.y);\n      const label = this.createLabel(nodesGroup, pos, value);\n      const node_transition = this.applyNodeTransition(current_node, pos);\n      const label_transition = this.applyLabelTransition(label, pos);\n      indexNodes.set(value, [index++, current_node]);\n      nodeTransitions.push(node_transition);\n      labelTransitions.push(label_transition);\n    });\n\n    // Draw connectors\n    this.graph.get_nodes().forEach((node, value) => {\n      let pointers = this.graph.get_pointers(value);\n      if (pointers != null && pointers.size > 0) {\n        const entry = indexNodes.get(value);\n        if (!entry) return; // safety check\n\n        const [index, currentNode] = entry;\n        const current_node_pos = this.getPosition(index, total, 350, 200);\n        pointers.forEach((weights, pointer) => {\n          const targetEntry = indexNodes.get(pointer.get_value());\n          if (!targetEntry) return;\n          const [targetIndex, _] = targetEntry;\n          const target_node_pos = this.getPosition(targetIndex, total, 350, 200);\n          const weightText = weights.join(\", \"); // Get the weight(s) as a string\n\n          if (this.hasMutualPointer(value, pointer.get_value())) {\n            const curvedPath = this.createCurvedLine(linesGroup, current_node_pos, target_node_pos, 0.1);\n            // Pass the curved path selection to createLineLabel\n            this.createLineLabel(linesGroup, curvedPath, weightText);\n          } else {\n            const straightLine = this.createLine(linesGroup, current_node_pos, target_node_pos);\n            // Use a type assertion here to tell TypeScript it's the correct union type\n            this.createLineLabel(linesGroup, straightLine, weightText);\n          }\n        });\n      }\n    });\n    await Promise.all([...nodeTransitions, ...labelTransitions]);\n  }\n\n  // Creates a label for a line (edge)\n  // Creates a label for a line (edge)\n  createLineLabel(group, lineOrPath, txt) {\n    // Check if the element is a line or a path\n    const isLine = lineOrPath.node() instanceof SVGLineElement;\n\n    // Append text element first to get its dimensions\n    const text = group.append(\"text\").style(\"fill\", \"black\").style(\"font-size\", \"12px\") // Smaller font size for edge labels\n    .style(\"pointer-events\", \"none\") // Prevent text from interfering with mouse events\n    .text(txt); // Set the text content\n\n    if (isLine) {\n      // For straight lines, place the text near the midpoint with an increased offset\n      const line = lineOrPath;\n      const x1 = parseFloat(line.attr(\"x1\"));\n      const y1 = parseFloat(line.attr(\"y1\"));\n      const x2 = parseFloat(line.attr(\"x2\"));\n      const y2 = parseFloat(line.attr(\"y2\"));\n\n      // Calculate midpoint\n      const midX = (x1 + x2) / 2;\n      const midY = (y1 + y2) / 2;\n\n      // Calculate perpendicular offset - Increased offset for better separation\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const lineLength = Math.sqrt(dx * dx + dy * dy);\n      const offsetAmount = 15; // Increase this value to move the label further away\n      const offsetX = lineLength === 0 ? 0 : -dy / lineLength * offsetAmount;\n      const offsetY = lineLength === 0 ? 0 : dx / lineLength * offsetAmount;\n      text.attr(\"x\", midX + offsetX).attr(\"y\", midY + offsetY).attr(\"text-anchor\", \"middle\") // Center the text horizontally\n      .attr(\"alignment-baseline\", \"middle\"); // Center the text vertically\n\n      // --- Add Background Rectangle for straight lines ---\n      const bbox = text.node().getBBox(); // Get text bounding box\n\n      // Append rectangle before the text (in SVG z-order)\n      group.insert(\"rect\", \"text\") // Insert the rect before the text element\n      .attr(\"x\", bbox.x - 2) // Add a little padding\n      .attr(\"y\", bbox.y - 2) // Add a little padding\n      .attr(\"width\", bbox.width + 4) // Add padding\n      .attr(\"height\", bbox.height + 4) // Add padding\n      .attr(\"fill\", \"white\") // Background color\n      .attr(\"stroke\", \"none\"); // No border\n      // Ensure the rectangle is positioned correctly relative to the text's calculated position.\n      // D3's getBBox gives coordinates relative to the SVG canvas or nearest positioned ancestor.\n      // We need to adjust the rect's position based on where the text was placed.\n      // A more robust way is to calculate the rect position relative to the text's anchor point (midX + offsetX, midY + offsetY)\n      // However, given the middle anchor and baseline, bbox.x/y are likely relative to that,\n      // so just using bbox.x and bbox.y directly might not work as expected.\n\n      // A simpler approach is to calculate the top-left corner based on the centered text position and bbox size\n      group.insert(\"rect\", \"text\") // Insert the rect before the text element\n      .attr(\"x\", midX + offsetX - bbox.width / 2 - 2) // Calculate based on center and bbox width\n      .attr(\"y\", midY + offsetY - bbox.height / 2 - 2) // Calculate based on center and bbox height\n      .attr(\"width\", bbox.width + 4) // Add padding\n      .attr(\"height\", bbox.height + 4) // Add padding\n      .attr(\"fill\", \"white\") // Background color\n      .attr(\"stroke\", \"none\"); // No border\n    } else {\n      // For curved paths, use textPath to place text along the curve\n      const path = lineOrPath;\n      const pathId = path.attr(\"id\"); // Get the unique ID of the path\n\n      // Append textPath and link it to the curved path using its ID\n      text.append(\"textPath\")\n      // Use full URL for xlink:href for better compatibility\n      .attr(\"xlink:href\", (d, i, nodes) => `${window.location.href}#${pathId}`)\n      // Adjust startOffset if needed to prevent overlap with arrow marker or other labels\n      .attr(\"startOffset\", \"55%\") // Start the text slightly after the midpoint\n      .attr(\"text-anchor\", \"middle\"); // Center the text along the path\n\n      // --- Background for Curved Line Labels (More Complex) ---\n      // Adding a background rectangle that precisely follows a curved textPath is complicated.\n      // For curved lines, adjusting curvature and startOffset is usually the primary approach.\n      // If needed, we could add a simple rectangle at the midpoint like straight lines,\n      // but it wouldn't follow the curve. Let's omit this for now unless the problem persists\n      // and we decide not to use textPath for curved lines.\n    }\n    return text; // Return the text element selection\n  }\n  hasMutualPointer(from, to) {\n    const fromPointers = this.graph.get_pointers(from);\n    const toPointers = this.graph.get_pointers(to);\n    if (!fromPointers || !toPointers) return false;\n\n    // Console logs can be removed in production code\n    // console.log(\"From Node:\", this.graph.get_node(from));\n    // console.log(\"To Node:\", this.graph.get_node(to));\n    // console.log(\"From Pointers:\", fromPointers);\n    // console.log(\"To Pointers:\", toPointers);\n    // console.log(\"From has To?\", fromPointers.has(this.graph.get_node(to) as FA_Node));\n    // console.log(\"To has From?\", toPointers.has(this.graph.get_node(from) as FA_Node));\n\n    return fromPointers.has(this.graph.get_node(to)) && toPointers.has(this.graph.get_node(from));\n  }\n  createCurvedLine(group, from, to, curvature = 0.3) {\n    // Midpoint between from and to\n    const midX = (from.x + to.x) / 2;\n    const midY = (from.y + to.y) / 2;\n\n    // Offset for the curve (perpendicular to the line)\n    const dx = to.x - from.x;\n    const dy = to.y - from.y;\n    const norm = Math.sqrt(dx * dx + dy * dy);\n    const offsetX = -dy * curvature;\n    const offsetY = dx * curvature;\n    const controlX = midX + offsetX;\n    const controlY = midY + offsetY;\n    const pathData = `M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;\n    const uniqueId = `curved-path-${pathIdCounter++}`; // Generate a unique ID\n\n    return group.append(\"path\").attr(\"id\", uniqueId) // Assign the unique ID\n    .attr(\"d\", pathData).attr(\"fill\", \"none\").attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"marker-end\", \"url(#arrow)\");\n  }\n  createLine(svgGroup, start, end, strokeColor = \"black\", strokeWidth = 2, opacity = 1) {\n    return svgGroup.append(\"line\").attr(\"x1\", start.x).attr(\"y1\", start.y).attr(\"x2\", end.x).attr(\"y2\", end.y).attr(\"stroke\", strokeColor).attr(\"stroke-width\", strokeWidth).style(\"opacity\", opacity).attr(\"marker-end\", \"url(#arrow)\");\n  }\n  createLabel(nodesGroup, position, txt) {\n    return nodesGroup.append(\"text\").attr(\"x\", position.x).attr(\"y\", position.y).attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\").attr(\"alignment-baseline\", \"middle\").style(\"fill\", \"black\").style(\"font-size\", \"20px\").text(txt);\n  }\n  createNode(nodesGroup, cx, cy, r = 20, className = \"node\", opacity = 0) {\n    return nodesGroup.append(\"circle\").attr(\"cx\", cx).attr(\"cy\", cy).attr(\"r\", r).attr(\"class\", className).style(\"opacity\", opacity);\n  }\n  applyNodeTransition(node, position, duration = 1000) {\n    return new Promise(resolve => {\n      node.transition().duration(duration).attr(\"cx\", position.x).attr(\"cy\", position.y).style(\"opacity\", 1).attr(\"stroke\", \"black\").attr(\"stroke-width\", 2).attr(\"fill\", \"white\").on(\"end\", () => resolve());\n    });\n  }\n  applyLabelTransition(label, position, duration = 1000) {\n    return new Promise(resolve => {\n      label.transition().duration(duration).style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y).on(\"end\", () => resolve());\n    });\n  }\n\n  // Gets the position in a shaped form\n  getPosition(index, numberOfNodes, centerX, centerY, radius = 150) {\n    const angle = 2 * Math.PI * index / numberOfNodes;\n\n    // Calculate x and y coordinates using polar to Cartesian conversion\n    const x = radius * Math.cos(angle);\n    const y = radius * Math.sin(angle);\n    return {\n      x: x + centerX,\n      y: y + centerY\n    };\n  }\n}","map":{"version":3,"names":["pathIdCounter","FAAddAllInstruction","constructor","graph","process","svg","nodeTransitions","labelTransitions","linesGroup","append","attr","nodesGroup","indexNodes","Map","index","total","get_nodes","size","forEach","node","value","pos","getPosition","current_node","createNode","x","y","label","createLabel","node_transition","applyNodeTransition","label_transition","applyLabelTransition","set","push","pointers","get_pointers","entry","get","currentNode","current_node_pos","weights","pointer","targetEntry","get_value","targetIndex","_","target_node_pos","weightText","join","hasMutualPointer","curvedPath","createCurvedLine","createLineLabel","straightLine","createLine","Promise","all","group","lineOrPath","txt","isLine","SVGLineElement","text","style","line","x1","parseFloat","y1","x2","y2","midX","midY","dx","dy","lineLength","Math","sqrt","offsetAmount","offsetX","offsetY","bbox","getBBox","insert","width","height","path","pathId","d","i","nodes","window","location","href","from","to","fromPointers","toPointers","has","get_node","curvature","norm","controlX","controlY","pathData","uniqueId","svgGroup","start","end","strokeColor","strokeWidth","opacity","position","cx","cy","r","className","duration","resolve","transition","on","numberOfNodes","centerX","centerY","radius","angle","PI","cos","sin"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_all_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\nimport {FA_Node} from \"../structures/fa_node\";\r\n\r\n// Counter to generate unique IDs for curved paths\r\nlet pathIdCounter = 0;\r\n\r\nexport class FAAddAllInstruction implements Instruction {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    constructor(graph: FA_Graph) {\r\n        this.graph = graph;\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n        const nodeTransitions: Promise<void>[] = [];\r\n        const labelTransitions: Promise<void>[] = [];\r\n        // Ensure the 'lines' group is added first so lines are behind nodes and labels\r\n        const linesGroup = svg.append(\"g\").attr(\"id\", \"lines\") as unknown as d3.Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        const nodesGroup = (svg.append(\"g\") as unknown) as Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        let indexNodes: Map<string | number, [number, d3.Selection<SVGCircleElement, unknown, null, undefined>]> = new Map();\r\n        let index = 0;\r\n        const total = this.graph.get_nodes().size;\r\n\r\n        // Draw all nodes\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            const pos = this.getPosition(index, total, 350, 200);\r\n            const current_node = this.createNode(nodesGroup, pos.x, pos.y);\r\n            const label = this.createLabel(nodesGroup, pos, value as string)\r\n            const node_transition = this.applyNodeTransition(current_node, pos);\r\n            const label_transition = this.applyLabelTransition(label, pos);\r\n\r\n            indexNodes.set(value, [index++, current_node]);\r\n            nodeTransitions.push(node_transition);\r\n            labelTransitions.push(label_transition);\r\n        });\r\n\r\n        // Draw connectors\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n\r\n            let pointers = this.graph.get_pointers(value);\r\n\r\n            if (pointers != null && pointers.size > 0) {\r\n\r\n                const entry = indexNodes.get(value);\r\n                if (!entry) return; // safety check\r\n\r\n                const [index, currentNode] = entry;\r\n                const current_node_pos = this.getPosition(index, total, 350, 200);\r\n\r\n                pointers.forEach((weights, pointer) => {\r\n                    const targetEntry = indexNodes.get(pointer.get_value());\r\n                    if (!targetEntry) return;\r\n\r\n                    const [targetIndex, _] = targetEntry;\r\n                    const target_node_pos = this.getPosition(targetIndex, total, 350, 200);\r\n\r\n                    const weightText = weights.join(\", \"); // Get the weight(s) as a string\r\n\r\n                    if (this.hasMutualPointer(value, pointer.get_value())){\r\n                        const curvedPath = this.createCurvedLine(linesGroup, current_node_pos, target_node_pos, 0.1);\r\n                        // Pass the curved path selection to createLineLabel\r\n                        this.createLineLabel(linesGroup, curvedPath, weightText);\r\n                    }\r\n                    else\r\n                    {\r\n                        const straightLine = this.createLine(linesGroup, current_node_pos, target_node_pos);\r\n                        // Use a type assertion here to tell TypeScript it's the correct union type\r\n                        this.createLineLabel(linesGroup, straightLine as d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>, weightText);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        await Promise.all([...nodeTransitions, ...labelTransitions]);\r\n    }\r\n\r\n    // Creates a label for a line (edge)\r\n    // Creates a label for a line (edge)\r\n    createLineLabel(\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        lineOrPath: d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>,\r\n        txt: string\r\n    ): d3.Selection<SVGTextElement, unknown, null, undefined> {\r\n\r\n        // Check if the element is a line or a path\r\n        const isLine = lineOrPath.node() instanceof SVGLineElement;\r\n\r\n        // Append text element first to get its dimensions\r\n        const text = group.append(\"text\")\r\n            .style(\"fill\", \"black\")\r\n            .style(\"font-size\", \"12px\") // Smaller font size for edge labels\r\n            .style(\"pointer-events\", \"none\") // Prevent text from interfering with mouse events\r\n            .text(txt); // Set the text content\r\n\r\n        if (isLine) {\r\n            // For straight lines, place the text near the midpoint with an increased offset\r\n            const line = lineOrPath as d3.Selection<SVGLineElement, unknown, null, undefined>;\r\n            const x1 = parseFloat(line.attr(\"x1\"));\r\n            const y1 = parseFloat(line.attr(\"y1\"));\r\n            const x2 = parseFloat(line.attr(\"x2\"));\r\n            const y2 = parseFloat(line.attr(\"y2\"));\r\n\r\n            // Calculate midpoint\r\n            const midX = (x1 + x2) / 2;\r\n            const midY = (y1 + y2) / 2;\r\n\r\n            // Calculate perpendicular offset - Increased offset for better separation\r\n            const dx = x2 - x1;\r\n            const dy = y2 - y1;\r\n            const lineLength = Math.sqrt(dx * dx + dy * dy);\r\n            const offsetAmount = 15; // Increase this value to move the label further away\r\n            const offsetX = lineLength === 0 ? 0 : (-dy / lineLength) * offsetAmount;\r\n            const offsetY = lineLength === 0 ? 0 : (dx / lineLength) * offsetAmount;\r\n\r\n            text.attr(\"x\", midX + offsetX)\r\n                .attr(\"y\", midY + offsetY)\r\n                .attr(\"text-anchor\", \"middle\") // Center the text horizontally\r\n                .attr(\"alignment-baseline\", \"middle\"); // Center the text vertically\r\n\r\n            // --- Add Background Rectangle for straight lines ---\r\n            const bbox = (text.node() as SVGTextElement).getBBox(); // Get text bounding box\r\n\r\n            // Append rectangle before the text (in SVG z-order)\r\n            group.insert(\"rect\", \"text\") // Insert the rect before the text element\r\n                .attr(\"x\", bbox.x - 2) // Add a little padding\r\n                .attr(\"y\", bbox.y - 2) // Add a little padding\r\n                .attr(\"width\", bbox.width + 4) // Add padding\r\n                .attr(\"height\", bbox.height + 4) // Add padding\r\n                .attr(\"fill\", \"white\") // Background color\r\n                .attr(\"stroke\", \"none\"); // No border\r\n            // Ensure the rectangle is positioned correctly relative to the text's calculated position.\r\n            // D3's getBBox gives coordinates relative to the SVG canvas or nearest positioned ancestor.\r\n            // We need to adjust the rect's position based on where the text was placed.\r\n            // A more robust way is to calculate the rect position relative to the text's anchor point (midX + offsetX, midY + offsetY)\r\n            // However, given the middle anchor and baseline, bbox.x/y are likely relative to that,\r\n            // so just using bbox.x and bbox.y directly might not work as expected.\r\n\r\n            // A simpler approach is to calculate the top-left corner based on the centered text position and bbox size\r\n            group.insert(\"rect\", \"text\") // Insert the rect before the text element\r\n                .attr(\"x\", (midX + offsetX) - bbox.width / 2 - 2) // Calculate based on center and bbox width\r\n                .attr(\"y\", (midY + offsetY) - bbox.height / 2 - 2) // Calculate based on center and bbox height\r\n                .attr(\"width\", bbox.width + 4) // Add padding\r\n                .attr(\"height\", bbox.height + 4) // Add padding\r\n                .attr(\"fill\", \"white\") // Background color\r\n                .attr(\"stroke\", \"none\"); // No border\r\n\r\n\r\n        } else {\r\n            // For curved paths, use textPath to place text along the curve\r\n            const path = lineOrPath as d3.Selection<SVGPathElement, unknown, null, undefined>;\r\n            const pathId = path.attr(\"id\"); // Get the unique ID of the path\r\n\r\n            // Append textPath and link it to the curved path using its ID\r\n            text.append(\"textPath\")\r\n                // Use full URL for xlink:href for better compatibility\r\n                .attr(\"xlink:href\", (d, i, nodes) => `${window.location.href}#${pathId}`)\r\n                // Adjust startOffset if needed to prevent overlap with arrow marker or other labels\r\n                .attr(\"startOffset\", \"55%\") // Start the text slightly after the midpoint\r\n                .attr(\"text-anchor\", \"middle\"); // Center the text along the path\r\n\r\n            // --- Background for Curved Line Labels (More Complex) ---\r\n            // Adding a background rectangle that precisely follows a curved textPath is complicated.\r\n            // For curved lines, adjusting curvature and startOffset is usually the primary approach.\r\n            // If needed, we could add a simple rectangle at the midpoint like straight lines,\r\n            // but it wouldn't follow the curve. Let's omit this for now unless the problem persists\r\n            // and we decide not to use textPath for curved lines.\r\n        }\r\n\r\n        return text; // Return the text element selection\r\n    }\r\n\r\n    hasMutualPointer(from: string | number, to: string | number): boolean {\r\n        const fromPointers = this.graph.get_pointers(from);\r\n        const toPointers = this.graph.get_pointers(to);\r\n\r\n        if (!fromPointers || !toPointers) return false;\r\n\r\n        // Console logs can be removed in production code\r\n        // console.log(\"From Node:\", this.graph.get_node(from));\r\n        // console.log(\"To Node:\", this.graph.get_node(to));\r\n        // console.log(\"From Pointers:\", fromPointers);\r\n        // console.log(\"To Pointers:\", toPointers);\r\n        // console.log(\"From has To?\", fromPointers.has(this.graph.get_node(to) as FA_Node));\r\n        // console.log(\"To has From?\", toPointers.has(this.graph.get_node(from) as FA_Node));\r\n\r\n        return fromPointers.has(this.graph.get_node(to) as FA_Node) && toPointers.has(this.graph.get_node(from) as FA_Node);\r\n    }\r\n\r\n\r\n    createCurvedLine(\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        from: { x: number, y: number },\r\n        to: { x: number, y: number },\r\n        curvature: number = 0.3\r\n    ): d3.Selection<SVGPathElement, unknown, null, undefined> {\r\n\r\n        // Midpoint between from and to\r\n        const midX = (from.x + to.x) / 2;\r\n        const midY = (from.y + to.y) / 2;\r\n\r\n        // Offset for the curve (perpendicular to the line)\r\n        const dx = to.x - from.x;\r\n        const dy = to.y - from.y;\r\n        const norm = Math.sqrt(dx * dx + dy * dy);\r\n        const offsetX = -dy * curvature;\r\n        const offsetY = dx * curvature;\r\n\r\n        const controlX = midX + offsetX;\r\n        const controlY = midY + offsetY;\r\n\r\n        const pathData = `M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;\r\n\r\n        const uniqueId = `curved-path-${pathIdCounter++}`; // Generate a unique ID\r\n\r\n        return group.append(\"path\")\r\n            .attr(\"id\", uniqueId) // Assign the unique ID\r\n            .attr(\"d\", pathData)\r\n            .attr(\"fill\", \"none\")\r\n            .attr(\"stroke\", \"black\")\r\n            .attr(\"stroke-width\", 2)\r\n            .attr(\"marker-end\", \"url(#arrow)\");\r\n    }\r\n\r\n    createLine(\r\n        svgGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        start: { x: number; y: number },\r\n        end: { x: number; y: number },\r\n        strokeColor: string = \"black\",\r\n        strokeWidth: number = 2,\r\n        opacity: number = 1\r\n    ): d3.Selection<SVGLineElement, unknown, null, undefined> {\r\n        return svgGroup.append(\"line\")\r\n            .attr(\"x1\", start.x)\r\n            .attr(\"y1\", start.y)\r\n            .attr(\"x2\", end.x)\r\n            .attr(\"y2\", end.y)\r\n            .attr(\"stroke\", strokeColor)\r\n            .attr(\"stroke-width\", strokeWidth)\r\n            .style(\"opacity\", opacity)\r\n            .attr(\"marker-end\", \"url(#arrow)\");\r\n    }\r\n\r\n\r\n    createLabel(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, position: { x: number, y: number }, txt: string): d3.Selection<SVGTextElement, unknown, null, undefined> {\r\n        return nodesGroup.append(\"text\")\r\n            .attr(\"x\", position.x)\r\n            .attr(\"y\", position.y)\r\n            .attr(\"class\", \"label\")\r\n            .attr(\"text-anchor\", \"middle\")\r\n            .attr(\"alignment-baseline\", \"middle\")\r\n            .style(\"fill\", \"black\")\r\n            .style(\"font-size\", \"20px\")\r\n            .text(txt);\r\n    }\r\n\r\n\r\n    createNode(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, cx: number, cy: number, r: number = 20,\r\n               className: string = \"node\", opacity: number = 0\r\n    ): d3.Selection<SVGCircleElement, unknown, null, undefined> {\r\n\r\n        return nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", cx)\r\n            .attr(\"cy\", cy)\r\n            .attr(\"r\", r)\r\n            .attr(\"class\", className)\r\n            .style(\"opacity\", opacity);\r\n    }\r\n\r\n    applyNodeTransition(\r\n        node: d3.Selection<SVGCircleElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            node.transition()\r\n                .duration(duration)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"white\")\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n    applyLabelTransition(\r\n        label: d3.Selection<SVGTextElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            label.transition()\r\n                .duration(duration)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y)\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n\r\n    // Gets the position in a shaped form\r\n    getPosition(index: number, numberOfNodes: number, centerX: number, centerY: number, radius: number = 150) {\r\n        const angle = (2 * Math.PI * index) / numberOfNodes;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}