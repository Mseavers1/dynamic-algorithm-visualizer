{"ast":null,"code":"// Counter to generate unique IDs for curved paths\nlet pathIdCounter=0;export class FAAddAllInstruction{constructor(graph){this.graph=void 0;this.graph=graph;pathIdCounter=0;}async process(svg){const nodeTransitions=[];const labelTransitions=[];const linesGroup=svg.append(\"g\").attr(\"id\",\"lines\");const layoutCenterX=350;const layoutCenterY=200;const nodesGroup=svg.append(\"g\");let indexNodes=new Map();let index=0;const total=this.graph.get_nodes().size;// Draw all nodes\nthis.graph.get_nodes().forEach((node,value)=>{const pos=this.getPosition(index,total,layoutCenterX,layoutCenterY);const is_starting_node=this.graph.is_starting_node(value);const is_final_node=this.graph.is_final_node(value);// Get the final node status\n// Create the node(s) and get the selections\nconst nodeSelections=this.createNode(nodesGroup,pos.x,pos.y,20,\"node\",0,is_final_node);const label=this.createLabel(nodesGroup,pos,value);// Apply transition to both the main circle and the outer ring\nconst node_transition=this.applyNodeTransition(nodeSelections.mainCircle,nodeSelections.outerRing,pos);const label_transition=this.applyLabelTransition(label,pos);indexNodes.set(value,[index++,nodeSelections.mainCircle]);nodeTransitions.push(node_transition);labelTransitions.push(label_transition);// If node is a starting state, add a line to it pointing away from the center\nif(is_starting_node){const startNodePos=pos;// Vector from layout center to starting node\nconst vx=startNodePos.x-layoutCenterX;const vy=startNodePos.y-layoutCenterY;// Normalize the vector\nconst magnitude=Math.sqrt(vx*vx+vy*vy);let unitVx=magnitude===0?0:vx/magnitude;let unitVy=magnitude===0?0:vy/magnitude;const angleDegrees=80;const angleRadians=angleDegrees*(Math.PI/180);const rotatedVx=unitVx*Math.cos(angleRadians)-unitVy*Math.sin(angleRadians);const rotatedVy=unitVx*Math.sin(angleRadians)+unitVy*Math.cos(angleRadians);const arrowLength=50;// Arrow start (offset from the node in rotated direction)\nconst arrowStartX=startNodePos.x+rotatedVx*arrowLength;const arrowStartY=startNodePos.y+rotatedVy*arrowLength;// Arrow end at the node\nconst arrowEndX=startNodePos.x;const arrowEndY=startNodePos.y;this.createLine(value,\"START\",linesGroup,{x:arrowStartX,y:arrowStartY},{x:arrowEndX,y:arrowEndY});}});// Draw connectors\nthis.graph.get_nodes().forEach((node,value)=>{let pointers=this.graph.get_pointers(value);if(pointers!=null&&pointers.size>0){const entry=indexNodes.get(value);if(!entry)return;// safety check\nconst[index,currentNode]=entry;const current_node_pos=this.getPosition(index,total,350,200);pointers.forEach((weights,pointer)=>{const targetEntry=indexNodes.get(pointer.get_value());if(!targetEntry)return;const[targetIndex,_]=targetEntry;const target_node_pos=this.getPosition(targetIndex,total,350,200);// Loop arrow back to self - if value and pointer are equal\nif(value==pointer.get_value()){// Calculate angle of the node from the layout center\nconst nodeAngle=Math.atan2(current_node_pos.y-layoutCenterY,current_node_pos.x-layoutCenterX);const loopRadius=40;const angleOffset=Math.PI/6;let startAngleRad,endAngleRad;startAngleRad=nodeAngle-angleOffset;endAngleRad=nodeAngle+angleOffset;// Calculate start and end points on the node's circumference\nconst startX=current_node_pos.x+20*Math.cos(startAngleRad);const startY=current_node_pos.y+20*Math.sin(startAngleRad);const endX=current_node_pos.x+20*Math.cos(endAngleRad);const endY=current_node_pos.y+20*Math.sin(endAngleRad);// Calculate control point for the arc\n// Position the control point further out along the radial direction\nconst controlPointDistance=20+loopRadius*2;const controlX=current_node_pos.x+controlPointDistance*Math.cos(nodeAngle);const controlY=current_node_pos.y+controlPointDistance*Math.sin(nodeAngle);// SVG path data for a self-loop using a quadratic bezier curve (Q)\nconst pathData=`M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;const uniqueId=`line-${value}-${pointer.get_value()}`;let defs=linesGroup.select(\"defs\");if(defs.empty()){defs=linesGroup.append(\"defs\");}defs.append(\"marker\").attr(\"id\",`arrow-${value}-${pointer.get_value()}`).attr(\"viewBox\",\"0 0 10 10\").attr(\"refX\",28).attr(\"refY\",5).attr(\"markerWidth\",6).attr(\"markerHeight\",6).attr(\"orient\",\"auto-start-reverse\").append(\"path\").attr(\"d\",\"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\",\"black\");const selfLoopPath=linesGroup.append(\"path\").attr(\"id\",uniqueId).attr(\"d\",pathData).attr(\"fill\",\"none\").attr(\"stroke\",\"black\").attr(\"stroke-width\",2).attr(\"marker-end\",`url(#arrow-${value}-${pointer.get_value()})`);// Create label for the self-loop\nthis.createLineLabel(linesGroup,selfLoopPath,weights);}else if(this.hasMutualPointer(value,pointer.get_value())){const curvedPath=this.createCurvedLine(value,pointer.get_value(),linesGroup,current_node_pos,target_node_pos,0.12);this.createLineLabel(linesGroup,curvedPath,weights);}else{const straightLine=this.createLine(value,pointer.get_value(),linesGroup,current_node_pos,target_node_pos);this.createLineLabel(linesGroup,straightLine,weights);}});}});await Promise.all([...nodeTransitions,...labelTransitions]);}// Creates a label for a line (edge) {Mostly generated through gpt and gemini -- edited by michael}\ncreateLineLabel(group,lineOrPath,txts){const isLine=lineOrPath.node()instanceof SVGLineElement;const createdLabels=[];txts.forEach((txt,index)=>{// Append a text element for each weight\nconst text=group.append(\"text\").style(\"fill\",\"red\").style(\"font-size\",\"16px\").style(\"pointer-events\",\"none\");if(isLine){const line=lineOrPath;const x1=parseFloat(line.attr(\"x1\"));const y1=parseFloat(line.attr(\"y1\"));const x2=parseFloat(line.attr(\"x2\"));const y2=parseFloat(line.attr(\"y2\"));// Calculate midpoint\nconst midX=(x1+x2)/2;const midY=(y1+y2)/2-10;// Calculate perpendicular offset\nconst dx=x2-x1;const dy=y2-y1;const lineLength=Math.sqrt(dx*dx+dy*dy);// Add a small check for zero length to avoid division by zero\nconst offsetX=lineLength===0?0:-dy/lineLength;const offsetY=lineLength===0?0:-dx/lineLength;// Adjust position based on the index for multiple labels\nconst labelSpacing=15;// Adjust this value for desired spacing\nconst totalOffset=(index-(txts.length-1)/2)*labelSpacing;// Center the labels around the midpoint\ntext.attr(\"x\",midX+offsetX*totalOffset).attr(\"y\",midY+offsetY*totalOffset).attr(\"text-anchor\",\"middle\").attr(\"alignment-baseline\",\"middle\").text(txt);}else{const path=lineOrPath;const pathId=path.attr(\"id\");// Adjust startOffset for each label along the curve\nconst startOffset=80-(txts.length-1)*2+(index-(txts.length-1)/2)*5;text.append(\"textPath\").attr(\"xlink:href\",`#${pathId}`).attr(\"startOffset\",`${startOffset}%`).attr(\"text-anchor\",\"middle\").text(txt);}createdLabels.push(text);});return createdLabels;}hasMutualPointer(from,to){const fromPointers=this.graph.get_pointers(from);const toPointers=this.graph.get_pointers(to);if(!fromPointers||!toPointers)return false;// Compare the node values (not the FA_Node instances)\nconst fromPointsTo=Array.from(fromPointers.keys()).some(p=>p.get_value()===to);const toPointsTo=Array.from(toPointers.keys()).some(p=>p.get_value()===from);return fromPointsTo&&toPointsTo;}createCurvedLine(nodeFrom,nodeTo,group,from,to){let curvature=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0.3;// Midpoint between from and to\nconst midX=(from.x+to.x)/2;const midY=(from.y+to.y)/2;// Offset for the curve (perpendicular to the line)\nconst dx=to.x-from.x;const dy=to.y-from.y;const norm=Math.sqrt(dx*dx+dy*dy);const offsetX=-dy*curvature;const offsetY=dx*curvature;const controlX=midX+offsetX;const controlY=midY+offsetY;const pathData=`M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;const uniqueId=`line-${nodeFrom}-${nodeTo}`;let defs=group.select(\"defs\");if(defs.empty()){defs=group.append(\"defs\");}defs.append(\"marker\").attr(\"id\",`arrow-${nodeFrom}-${nodeTo}`).attr(\"viewBox\",\"0 0 10 10\").attr(\"refX\",28).attr(\"refY\",5).attr(\"markerWidth\",6).attr(\"markerHeight\",6).attr(\"orient\",\"auto-start-reverse\").append(\"path\").attr(\"d\",\"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\",\"black\");return group.append(\"path\").attr(\"id\",uniqueId).attr(\"d\",pathData).attr(\"fill\",\"none\").attr(\"stroke\",\"black\").attr(\"stroke-width\",2).attr(\"marker-end\",`url(#arrow-${nodeFrom}-${nodeTo})`);}createLine(nodeFrom,nodeTo,svgGroup,start,end){let strokeColor=arguments.length>5&&arguments[5]!==undefined?arguments[5]:\"black\";let strokeWidth=arguments.length>6&&arguments[6]!==undefined?arguments[6]:2;let opacity=arguments.length>7&&arguments[7]!==undefined?arguments[7]:1;const uniqueId=`line-${nodeFrom}-${nodeTo}`;let defs=svgGroup.select(\"defs\");if(defs.empty()){defs=svgGroup.append(\"defs\");}defs.append(\"marker\").attr(\"id\",`arrow-${nodeFrom}-${nodeTo}`).attr(\"viewBox\",\"0 0 10 10\").attr(\"refX\",28).attr(\"refY\",5).attr(\"markerWidth\",6).attr(\"markerHeight\",6).attr(\"orient\",\"auto-start-reverse\").append(\"path\").attr(\"d\",\"M 0 0 L 10 5 L 0 10 z\").attr(\"fill\",\"black\");return svgGroup.append(\"line\").attr(\"id\",uniqueId).attr(\"x1\",start.x).attr(\"y1\",start.y).attr(\"x2\",end.x).attr(\"y2\",end.y).attr(\"stroke\",strokeColor).attr(\"stroke-width\",strokeWidth).style(\"opacity\",opacity).attr(\"marker-end\",`url(#arrow-${nodeFrom}-${nodeTo})`);}createLabel(nodesGroup,position,txt){return nodesGroup.append(\"text\").attr(\"x\",position.x).attr(\"y\",position.y).attr(\"class\",\"label\").attr(\"text-anchor\",\"middle\").attr(\"alignment-baseline\",\"middle\").style(\"fill\",\"black\").style(\"font-size\",\"20px\").text(txt);}createNode(nodesGroup,cx,cy){let r=arguments.length>3&&arguments[3]!==undefined?arguments[3]:20;let className=arguments.length>4&&arguments[4]!==undefined?arguments[4]:\"node\";let initialOpacity=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;let isFinalNode=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;// Create the main node circle\nconst mainCircle=nodesGroup.append(\"circle\").attr(\"cx\",cx).attr(\"cy\",cy).attr(\"r\",r).attr(\"class\",className).style(\"opacity\",initialOpacity);let outerRing=undefined;// If it's a final node, add a second circle with a larger radius\nif(isFinalNode){const outerRadius=r+5;outerRing=nodesGroup.append(\"circle\").attr(\"cx\",cx).attr(\"cy\",cy).attr(\"r\",outerRadius).attr(\"class\",className+\" final-node-ring\").style(\"fill\",\"none\").style(\"stroke\",\"black\").style(\"stroke-width\",2).style(\"opacity\",initialOpacity);}// Return an object containing both selections\nreturn{mainCircle,outerRing};}applyNodeTransition(mainCircle,outerRing,// Accept the optional outer ring\nposition){let duration=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1000;return new Promise(resolve=>{const mainCircleTransition=mainCircle.transition().duration(duration).attr(\"cx\",position.x).attr(\"cy\",position.y).style(\"opacity\",1).attr(\"stroke\",\"black\").attr(\"stroke-width\",2).attr(\"fill\",\"white\");// If an outer ring exists, apply the same transition to it\nif(outerRing){outerRing.transition().duration(duration).attr(\"cx\",position.x).attr(\"cy\",position.y).style(\"opacity\",1);}mainCircleTransition.on(\"end\",()=>resolve());});}applyLabelTransition(label,position){let duration=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1000;return new Promise(resolve=>{label.transition().duration(duration).style(\"opacity\",1).attr(\"x\",position.x).attr(\"y\",position.y).on(\"end\",()=>resolve());});}// Gets the position in a shaped form\ngetPosition(index,numberOfNodes,centerX,centerY){let radius=arguments.length>4&&arguments[4]!==undefined?arguments[4]:150;const angle=2*Math.PI*index/numberOfNodes;// Calculate x and y coordinates using polar to Cartesian conversion\nconst x=radius*Math.cos(angle);const y=radius*Math.sin(angle);return{x:x+centerX,y:y+centerY};}}","map":{"version":3,"names":["pathIdCounter","FAAddAllInstruction","constructor","graph","process","svg","nodeTransitions","labelTransitions","linesGroup","append","attr","layoutCenterX","layoutCenterY","nodesGroup","indexNodes","Map","index","total","get_nodes","size","forEach","node","value","pos","getPosition","is_starting_node","is_final_node","nodeSelections","createNode","x","y","label","createLabel","node_transition","applyNodeTransition","mainCircle","outerRing","label_transition","applyLabelTransition","set","push","startNodePos","vx","vy","magnitude","Math","sqrt","unitVx","unitVy","angleDegrees","angleRadians","PI","rotatedVx","cos","sin","rotatedVy","arrowLength","arrowStartX","arrowStartY","arrowEndX","arrowEndY","createLine","pointers","get_pointers","entry","get","currentNode","current_node_pos","weights","pointer","targetEntry","get_value","targetIndex","_","target_node_pos","nodeAngle","atan2","loopRadius","angleOffset","startAngleRad","endAngleRad","startX","startY","endX","endY","controlPointDistance","controlX","controlY","pathData","uniqueId","defs","select","empty","selfLoopPath","createLineLabel","hasMutualPointer","curvedPath","createCurvedLine","straightLine","Promise","all","group","lineOrPath","txts","isLine","SVGLineElement","createdLabels","txt","text","style","line","x1","parseFloat","y1","x2","y2","midX","midY","dx","dy","lineLength","offsetX","offsetY","labelSpacing","totalOffset","length","path","pathId","startOffset","from","to","fromPointers","toPointers","fromPointsTo","Array","keys","some","p","toPointsTo","nodeFrom","nodeTo","curvature","arguments","undefined","norm","svgGroup","start","end","strokeColor","strokeWidth","opacity","position","cx","cy","r","className","initialOpacity","isFinalNode","outerRadius","duration","resolve","mainCircleTransition","transition","on","numberOfNodes","centerX","centerY","radius","angle"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/Instructions/fa_add_all_instruction.tsx"],"sourcesContent":["import {Instruction} from \"./i_instruction\";\r\nimport {BaseType, Selection} from \"d3\";\r\nimport {FA_Graph} from \"../structures/fa_graph\";\r\nimport {FA_Node} from \"../structures/fa_node\";\r\n\r\n// Counter to generate unique IDs for curved paths\r\nlet pathIdCounter = 0;\r\n\r\nexport class FAAddAllInstruction implements Instruction {\r\n\r\n    private graph: FA_Graph;\r\n\r\n    constructor(graph: FA_Graph) {\r\n        this.graph = graph;\r\n        pathIdCounter = 0\r\n    }\r\n\r\n    async process(svg: Selection<BaseType, unknown, HTMLElement, any>): Promise<void> {\r\n        const nodeTransitions: Promise<void>[] = [];\r\n        const labelTransitions: Promise<void>[] = [];\r\n        const linesGroup = svg.append(\"g\").attr(\"id\", \"lines\") as unknown as d3.Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        const layoutCenterX = 350;\r\n        const layoutCenterY = 200;\r\n\r\n        const nodesGroup = (svg.append(\"g\") as unknown) as Selection<SVGGElement, unknown, null, undefined>;\r\n\r\n        let indexNodes: Map<string | number, [number, d3.Selection<SVGCircleElement, unknown, null, undefined>]> = new Map();\r\n        let index = 0;\r\n        const total = this.graph.get_nodes().size;\r\n\r\n        // Draw all nodes\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n            const pos = this.getPosition(index, total, layoutCenterX, layoutCenterY);\r\n            const is_starting_node = this.graph.is_starting_node(value);\r\n            const is_final_node = this.graph.is_final_node(value); // Get the final node status\r\n\r\n            // Create the node(s) and get the selections\r\n            const nodeSelections = this.createNode(nodesGroup, pos.x, pos.y, 20, \"node\", 0, is_final_node);\r\n\r\n            const label = this.createLabel(nodesGroup, pos, value as string)\r\n\r\n            // Apply transition to both the main circle and the outer ring\r\n            const node_transition = this.applyNodeTransition(nodeSelections.mainCircle, nodeSelections.outerRing, pos);\r\n            const label_transition = this.applyLabelTransition(label, pos);\r\n\r\n            indexNodes.set(value, [index++, nodeSelections.mainCircle]);\r\n            nodeTransitions.push(node_transition);\r\n            labelTransitions.push(label_transition);\r\n\r\n            // If node is a starting state, add a line to it pointing away from the center\r\n            if (is_starting_node) {\r\n                const startNodePos = pos;\r\n\r\n                // Vector from layout center to starting node\r\n                const vx = startNodePos.x - layoutCenterX;\r\n                const vy = startNodePos.y - layoutCenterY;\r\n\r\n                // Normalize the vector\r\n                const magnitude = Math.sqrt(vx * vx + vy * vy);\r\n                let unitVx = magnitude === 0 ? 0 : vx / magnitude;\r\n                let unitVy = magnitude === 0 ? 0 : vy / magnitude;\r\n\r\n                const angleDegrees = 80;\r\n                const angleRadians = angleDegrees * (Math.PI / 180);\r\n\r\n                const rotatedVx = unitVx * Math.cos(angleRadians) - unitVy * Math.sin(angleRadians);\r\n                const rotatedVy = unitVx * Math.sin(angleRadians) + unitVy * Math.cos(angleRadians);\r\n\r\n                const arrowLength = 50;\r\n\r\n                // Arrow start (offset from the node in rotated direction)\r\n                const arrowStartX = startNodePos.x + rotatedVx * arrowLength;\r\n                const arrowStartY = startNodePos.y + rotatedVy * arrowLength;\r\n\r\n                // Arrow end at the node\r\n                const arrowEndX = startNodePos.x;\r\n                const arrowEndY = startNodePos.y;\r\n\r\n                this.createLine(value as string, \"START\", linesGroup, { x: arrowStartX, y: arrowStartY }, { x: arrowEndX, y: arrowEndY });\r\n            }\r\n\r\n        });\r\n\r\n        // Draw connectors\r\n        this.graph.get_nodes().forEach((node, value) => {\r\n\r\n            let pointers = this.graph.get_pointers(value);\r\n\r\n            if (pointers != null && pointers.size > 0) {\r\n\r\n                const entry = indexNodes.get(value);\r\n                if (!entry) return; // safety check\r\n\r\n                const [index, currentNode] = entry;\r\n                const current_node_pos = this.getPosition(index, total, 350, 200);\r\n\r\n                pointers.forEach((weights, pointer) => {\r\n                    const targetEntry = indexNodes.get(pointer.get_value());\r\n                    if (!targetEntry) return;\r\n\r\n                    const [targetIndex, _] = targetEntry;\r\n                    const target_node_pos = this.getPosition(targetIndex, total, 350, 200);\r\n\r\n                    // Loop arrow back to self - if value and pointer are equal\r\n                    if (value == pointer.get_value()) {\r\n                        // Calculate angle of the node from the layout center\r\n                        const nodeAngle = Math.atan2(current_node_pos.y - layoutCenterY, current_node_pos.x - layoutCenterX);\r\n\r\n                        const loopRadius = 40;\r\n                        const angleOffset = Math.PI / 6;\r\n\r\n                        let startAngleRad, endAngleRad;\r\n\r\n                        startAngleRad = nodeAngle - angleOffset;\r\n                        endAngleRad = nodeAngle + angleOffset;\r\n\r\n                        // Calculate start and end points on the node's circumference\r\n                        const startX = current_node_pos.x + 20 * Math.cos(startAngleRad);\r\n                        const startY = current_node_pos.y + 20 * Math.sin(startAngleRad);\r\n                        const endX = current_node_pos.x + 20 * Math.cos(endAngleRad);\r\n                        const endY = current_node_pos.y + 20 * Math.sin(endAngleRad);\r\n\r\n                        // Calculate control point for the arc\r\n                        // Position the control point further out along the radial direction\r\n                        const controlPointDistance = 20 + loopRadius * 2;\r\n                        const controlX = current_node_pos.x + controlPointDistance * Math.cos(nodeAngle);\r\n                        const controlY = current_node_pos.y + controlPointDistance * Math.sin(nodeAngle);\r\n\r\n                        // SVG path data for a self-loop using a quadratic bezier curve (Q)\r\n                        const pathData = `M ${startX},${startY} Q ${controlX},${controlY} ${endX},${endY}`;\r\n\r\n                        const uniqueId = `line-${value as string}-${pointer.get_value() as string}`;\r\n\r\n                        let defs = linesGroup.select<SVGDefsElement>(\"defs\");\r\n                        if (defs.empty()) {\r\n                            defs = linesGroup.append<SVGDefsElement>(\"defs\");\r\n                        }\r\n                        defs.append(\"marker\")\r\n                            .attr(\"id\", `arrow-${value as string}-${pointer.get_value() as string}`)\r\n                            .attr(\"viewBox\", \"0 0 10 10\")\r\n                            .attr(\"refX\", 28)\r\n                            .attr(\"refY\", 5)\r\n                            .attr(\"markerWidth\", 6)\r\n                            .attr(\"markerHeight\", 6)\r\n                            .attr(\"orient\", \"auto-start-reverse\")\r\n                            .append(\"path\")\r\n                            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n                            .attr(\"fill\", \"black\");\r\n\r\n                        const selfLoopPath = linesGroup.append(\"path\")\r\n                            .attr(\"id\", uniqueId)\r\n                            .attr(\"d\", pathData)\r\n                            .attr(\"fill\", \"none\")\r\n                            .attr(\"stroke\", \"black\")\r\n                            .attr(\"stroke-width\", 2)\r\n                            .attr(\"marker-end\", `url(#arrow-${value as string}-${pointer.get_value() as string})`);\r\n\r\n                        // Create label for the self-loop\r\n                        this.createLineLabel(linesGroup, selfLoopPath, weights as string[]);\r\n                    }\r\n                    else if (this.hasMutualPointer(value, pointer.get_value())){\r\n                        const curvedPath = this.createCurvedLine(value as string, pointer.get_value() as string, linesGroup, current_node_pos, target_node_pos, 0.12);\r\n                        this.createLineLabel(linesGroup, curvedPath, weights as string[]);\r\n                    }\r\n                    else\r\n                    {\r\n                        const straightLine = this.createLine(value as string, pointer.get_value() as string, linesGroup, current_node_pos, target_node_pos);\r\n                        this.createLineLabel(linesGroup, straightLine as d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>, weights as string[]);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        await Promise.all([...nodeTransitions, ...labelTransitions]);\r\n    }\r\n\r\n    // Creates a label for a line (edge) {Mostly generated through gpt and gemini -- edited by michael}\r\n    createLineLabel(\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        lineOrPath: d3.Selection<SVGLineElement | SVGPathElement, unknown, null, undefined>,\r\n        txts: string[]\r\n    ): d3.Selection<SVGTextElement, unknown, null, undefined>[] {\r\n\r\n        const isLine = lineOrPath.node() instanceof SVGLineElement;\r\n        const createdLabels: d3.Selection<SVGTextElement, unknown, null, undefined>[] = [];\r\n\r\n        txts.forEach((txt, index) => {\r\n            // Append a text element for each weight\r\n            const text = group.append(\"text\")\r\n                .style(\"fill\", \"red\")\r\n                .style(\"font-size\", \"16px\")\r\n                .style(\"pointer-events\", \"none\");\r\n\r\n            if (isLine) {\r\n                const line = lineOrPath as d3.Selection<SVGLineElement, unknown, null, undefined>;\r\n                const x1 = parseFloat(line.attr(\"x1\"));\r\n                const y1 = parseFloat(line.attr(\"y1\"));\r\n                const x2 = parseFloat(line.attr(\"x2\"));\r\n                const y2 = parseFloat(line.attr(\"y2\"));\r\n\r\n                // Calculate midpoint\r\n                const midX = (x1 + x2) / 2;\r\n                const midY = (y1 + y2) / 2 - 10;\r\n\r\n                // Calculate perpendicular offset\r\n                const dx = x2 - x1;\r\n                const dy = y2 - y1;\r\n                const lineLength = Math.sqrt(dx * dx + dy * dy);\r\n                // Add a small check for zero length to avoid division by zero\r\n                const offsetX = lineLength === 0 ? 0 : (-dy / lineLength);\r\n                const offsetY = lineLength === 0 ? 0 : (-dx / lineLength);\r\n\r\n                // Adjust position based on the index for multiple labels\r\n                const labelSpacing = 15; // Adjust this value for desired spacing\r\n                const totalOffset = (index - (txts.length - 1) / 2) * labelSpacing; // Center the labels around the midpoint\r\n\r\n                text.attr(\"x\", midX + offsetX * totalOffset)\r\n                    .attr(\"y\", midY + offsetY * totalOffset)\r\n                    .attr(\"text-anchor\", \"middle\")\r\n                    .attr(\"alignment-baseline\", \"middle\")\r\n                    .text(txt);\r\n\r\n            } else {\r\n                const path = lineOrPath as d3.Selection<SVGPathElement, unknown, null, undefined>;\r\n                const pathId = path.attr(\"id\");\r\n\r\n                // Adjust startOffset for each label along the curve\r\n                const startOffset = (80 - (txts.length - 1) * 2) + ((index - (txts.length - 1) / 2) * 5);\r\n\r\n                text.append(\"textPath\")\r\n                    .attr(\"xlink:href\", `#${pathId}`)\r\n                    .attr(\"startOffset\", `${startOffset}%`)\r\n                    .attr(\"text-anchor\", \"middle\")\r\n                    .text(txt);\r\n            }\r\n            createdLabels.push(text);\r\n        });\r\n\r\n        return createdLabels;\r\n    }\r\n\r\n    hasMutualPointer(from: string | number, to: string | number): boolean {\r\n        const fromPointers = this.graph.get_pointers(from);\r\n        const toPointers = this.graph.get_pointers(to);\r\n\r\n        if (!fromPointers || !toPointers) return false;\r\n\r\n        // Compare the node values (not the FA_Node instances)\r\n        const fromPointsTo = Array.from(fromPointers.keys()).some(p => p.get_value() === to);\r\n        const toPointsTo = Array.from(toPointers.keys()).some(p => p.get_value() === from);\r\n\r\n        return fromPointsTo && toPointsTo;\r\n    }\r\n\r\n\r\n    createCurvedLine(\r\n        nodeFrom: string,\r\n        nodeTo: string,\r\n        group: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        from: { x: number, y: number },\r\n        to: { x: number, y: number },\r\n        curvature: number = 0.3\r\n    ): d3.Selection<SVGPathElement, unknown, null, undefined> {\r\n\r\n        // Midpoint between from and to\r\n        const midX = (from.x + to.x) / 2;\r\n        const midY = (from.y + to.y) / 2;\r\n\r\n        // Offset for the curve (perpendicular to the line)\r\n        const dx = to.x - from.x;\r\n        const dy = to.y - from.y;\r\n        const norm = Math.sqrt(dx * dx + dy * dy);\r\n        const offsetX = -dy * curvature;\r\n        const offsetY = dx * curvature;\r\n\r\n        const controlX = midX + offsetX;\r\n        const controlY = midY + offsetY;\r\n\r\n        const pathData = `M ${from.x} ${from.y} Q ${controlX} ${controlY}, ${to.x} ${to.y}`;\r\n\r\n        const uniqueId = `line-${nodeFrom}-${nodeTo}`;\r\n\r\n        let defs = group.select<SVGDefsElement>(\"defs\");\r\n        if (defs.empty()) {\r\n            defs = group.append<SVGDefsElement>(\"defs\");\r\n        }\r\n\r\n        defs.append(\"marker\")\r\n            .attr(\"id\", `arrow-${nodeFrom}-${nodeTo}`)\r\n            .attr(\"viewBox\", \"0 0 10 10\")\r\n            .attr(\"refX\", 28)\r\n            .attr(\"refY\", 5)\r\n            .attr(\"markerWidth\", 6)\r\n            .attr(\"markerHeight\", 6)\r\n            .attr(\"orient\", \"auto-start-reverse\")\r\n            .append(\"path\")\r\n            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n            .attr(\"fill\", \"black\");\r\n\r\n        return group.append(\"path\")\r\n            .attr(\"id\", uniqueId)\r\n            .attr(\"d\", pathData)\r\n            .attr(\"fill\", \"none\")\r\n            .attr(\"stroke\", \"black\")\r\n            .attr(\"stroke-width\", 2)\r\n            .attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\r\n    }\r\n\r\n    createLine(\r\n        nodeFrom: String,\r\n        nodeTo: String,\r\n        svgGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        start: { x: number; y: number },\r\n        end: { x: number; y: number },\r\n        strokeColor: string = \"black\",\r\n        strokeWidth: number = 2,\r\n        opacity: number = 1\r\n    ): d3.Selection<SVGLineElement, unknown, null, undefined> {\r\n        const uniqueId = `line-${nodeFrom}-${nodeTo}`;\r\n\r\n        let defs = svgGroup.select<SVGDefsElement>(\"defs\");\r\n        if (defs.empty()) {\r\n            defs = svgGroup.append<SVGDefsElement>(\"defs\");\r\n        }\r\n\r\n        defs.append(\"marker\")\r\n            .attr(\"id\", `arrow-${nodeFrom}-${nodeTo}`)\r\n            .attr(\"viewBox\", \"0 0 10 10\")\r\n            .attr(\"refX\", 28)\r\n            .attr(\"refY\", 5)\r\n            .attr(\"markerWidth\", 6)\r\n            .attr(\"markerHeight\", 6)\r\n            .attr(\"orient\", \"auto-start-reverse\")\r\n            .append(\"path\")\r\n            .attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\")\r\n            .attr(\"fill\", \"black\");\r\n\r\n        return svgGroup.append(\"line\")\r\n            .attr(\"id\", uniqueId)\r\n            .attr(\"x1\", start.x)\r\n            .attr(\"y1\", start.y)\r\n            .attr(\"x2\", end.x)\r\n            .attr(\"y2\", end.y)\r\n            .attr(\"stroke\", strokeColor)\r\n            .attr(\"stroke-width\", strokeWidth)\r\n            .style(\"opacity\", opacity)\r\n            .attr(\"marker-end\", `url(#arrow-${nodeFrom}-${nodeTo})`);\r\n    }\r\n\r\n\r\n    createLabel(nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>, position: { x: number, y: number }, txt: string): d3.Selection<SVGTextElement, unknown, null, undefined> {\r\n        return nodesGroup.append(\"text\")\r\n            .attr(\"x\", position.x)\r\n            .attr(\"y\", position.y)\r\n            .attr(\"class\", \"label\")\r\n            .attr(\"text-anchor\", \"middle\")\r\n            .attr(\"alignment-baseline\", \"middle\")\r\n            .style(\"fill\", \"black\")\r\n            .style(\"font-size\", \"20px\")\r\n            .text(txt);\r\n    }\r\n\r\n\r\n    createNode(\r\n        nodesGroup: d3.Selection<SVGGElement, unknown, null, undefined>,\r\n        cx: number,\r\n        cy: number,\r\n        r: number = 20,\r\n        className: string = \"node\",\r\n        initialOpacity: number = 0,\r\n        isFinalNode: boolean = false\r\n    ): { mainCircle: d3.Selection<SVGCircleElement, unknown, null, undefined>, outerRing?: d3.Selection<SVGCircleElement, unknown, null, undefined> } {\r\n\r\n        // Create the main node circle\r\n        const mainCircle = nodesGroup.append(\"circle\")\r\n            .attr(\"cx\", cx)\r\n            .attr(\"cy\", cy)\r\n            .attr(\"r\", r)\r\n            .attr(\"class\", className)\r\n            .style(\"opacity\", initialOpacity);\r\n\r\n        let outerRing: d3.Selection<SVGCircleElement, unknown, null, undefined> | undefined = undefined;\r\n\r\n        // If it's a final node, add a second circle with a larger radius\r\n        if (isFinalNode) {\r\n            const outerRadius = r + 5;\r\n            outerRing = nodesGroup.append(\"circle\")\r\n                .attr(\"cx\", cx)\r\n                .attr(\"cy\", cy)\r\n                .attr(\"r\", outerRadius)\r\n                .attr(\"class\", className + \" final-node-ring\")\r\n                .style(\"fill\", \"none\")\r\n                .style(\"stroke\", \"black\")\r\n                .style(\"stroke-width\", 2)\r\n                .style(\"opacity\", initialOpacity);\r\n        }\r\n\r\n        // Return an object containing both selections\r\n        return { mainCircle, outerRing };\r\n    }\r\n\r\n    applyNodeTransition(\r\n        mainCircle: d3.Selection<SVGCircleElement, unknown, null, undefined>,\r\n        outerRing: d3.Selection<SVGCircleElement, unknown, null, undefined> | undefined, // Accept the optional outer ring\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n\r\n            const mainCircleTransition = mainCircle.transition()\r\n                .duration(duration)\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"stroke\", \"black\")\r\n                .attr(\"stroke-width\", 2)\r\n                .attr(\"fill\", \"white\");\r\n\r\n            // If an outer ring exists, apply the same transition to it\r\n            if (outerRing) {\r\n                outerRing.transition()\r\n                    .duration(duration)\r\n                    .attr(\"cx\", position.x)\r\n                    .attr(\"cy\", position.y)\r\n                    .style(\"opacity\", 1);\r\n            }\r\n\r\n            mainCircleTransition.on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n    applyLabelTransition(\r\n        label: d3.Selection<SVGTextElement, unknown, null, undefined>,\r\n        position: { x: number; y: number },\r\n        duration: number = 1000\r\n    ): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            label.transition()\r\n                .duration(duration)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y)\r\n                .on(\"end\", () => resolve());\r\n        });\r\n    }\r\n\r\n\r\n    // Gets the position in a shaped form\r\n    getPosition(index: number, numberOfNodes: number, centerX: number, centerY: number, radius: number = 150) {\r\n        const angle = (2 * Math.PI * index) / numberOfNodes;\r\n\r\n        // Calculate x and y coordinates using polar to Cartesian conversion\r\n        const x = radius * Math.cos(angle);\r\n        const y = radius * Math.sin(angle);\r\n\r\n        return { x: x + centerX, y: y + centerY };\r\n    }\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}