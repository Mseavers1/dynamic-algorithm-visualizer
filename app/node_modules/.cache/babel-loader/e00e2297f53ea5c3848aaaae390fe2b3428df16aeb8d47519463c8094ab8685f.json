{"ast":null,"code":"import * as d3 from \"d3\";\nexport class TreeAnimate {\n  constructor() {\n    this.instructions = void 0;\n    this.current_nodes = void 0;\n    this.processInstructions = async svg => {\n      for (let instruction of this.instructions) {\n        if (instruction.type === 'add' && instruction.value) {\n          // Wait for the previous node to finish its animation before adding the next one\n          await this.addNode(svg, instruction);\n        }\n        if (instruction.type === 'swap') {\n          await this.swapNodes(svg, this.current_nodes[instruction.toIndex], this.current_nodes[instruction.fromIndex]);\n          const i = this.current_nodes[instruction.toIndex].index;\n          this.current_nodes[instruction.toIndex].index = this.current_nodes[instruction.fromIndex].index;\n          this.current_nodes[instruction.fromIndex].index = i;\n          const node = this.current_nodes[instruction.toIndex];\n          this.current_nodes[instruction.toIndex] = this.current_nodes[instruction.fromIndex];\n          this.current_nodes[instruction.fromIndex] = node;\n        }\n      }\n      this.instructions = [];\n    };\n    this.addNode = (svg, instruction) => {\n      const position = this.getNodePosition(instruction.index);\n      const parentIndex = Math.floor((instruction.index - 1) / 2);\n      const hasParent = parentIndex >= 0 && this.current_nodes[parentIndex];\n      return new Promise(resolve => {\n        const nodeElement = svg.append(\"circle\").attr(\"cx\", 200) // Set starting x position\n        .attr(\"cy\", 200) // Set starting y position\n        .attr(\"r\", 20).attr(\"class\", \"node\").style(\"opacity\", 0); // Start with invisible node\n\n        const label = svg.append(\"text\").attr(\"x\", 200) // Same x position as the circle\n        .attr(\"y\", 200) // Same y position as the circle\n        .attr(\"class\", \"label\").attr(\"text-anchor\", \"middle\") // Center the text horizontally\n        .attr(\"alignment-baseline\", \"middle\") // Center the text vertically\n        .style(\"fill\", \"white\") // Set text color\n        .style(\"font-size\", \"12px\").text(instruction.value);\n        const newNode = {\n          node: nodeElement,\n          label: label,\n          index: instruction.index\n        };\n        let edge = null;\n        if (hasParent) {\n          const parentPos = this.getNodePosition(parentIndex);\n          edge = svg.append(\"line\").attr(\"x1\", parentPos.x).attr(\"y1\", parentPos.y).attr(\"x2\", 200) // Temporary start position\n          .attr(\"y2\", 200).attr(\"stroke\", \"white\").attr(\"stroke-width\", 2).style(\"opacity\", 0);\n        }\n        this.current_nodes.push(newNode);\n\n        // Animate the node: fade in and move\n        nodeElement.transition().duration(1000) // Duration of 1 second\n        .style(\"opacity\", 1) // Fade in the node\n        .attr(\"cx\", position.x).attr(\"cy\", position.y); // Keep y position constant for simplicity\n\n        label.transition().duration(1000) // Duration of 1 second (same as node)\n        .style(\"opacity\", 1).attr(\"x\", position.x).attr(\"y\", position.y);\n\n        // Resolve the promise after the animation duration\n        setTimeout(() => resolve(), 1000); // Wait for the animation to finish (1000ms)\n      });\n    };\n    this.getNodePosition = index => {\n      if (index < 0 || isNaN(index)) return {\n        x: 0,\n        y: 0\n      };\n      if (index === 0) return {\n        x: 250,\n        y: 50\n      }; // Root at the center\n\n      const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\n      const xSpacing = 200 / (depth + 1); // Adjust x spacing\n      const ySpacing = 80; // Vertical spacing\n\n      const parentIndex = Math.floor((index - 1) / 2);\n      const parentPos = this.getNodePosition(parentIndex);\n      const isLeftChild = index % 2 === 1;\n      const xOffset = isLeftChild ? -xSpacing : xSpacing;\n      return {\n        x: parentPos.x + xOffset,\n        y: parentPos.y + ySpacing\n      };\n    };\n    this.swapNodes = (svg, nodeA, nodeB) => {\n      //alert(nodes.length);\n\n      return new Promise(resolve => {\n        const node1 = nodeA.node;\n        const label1 = nodeA.label;\n        const node2 = nodeB.node;\n        const label2 = nodeB.label;\n        const node1Position = {\n          x: parseFloat(node1.attr(\"cx\")),\n          y: parseFloat(node1.attr(\"cy\"))\n        };\n        const node2Position = {\n          x: parseFloat(node2.attr(\"cx\")),\n          y: parseFloat(node2.attr(\"cy\"))\n        };\n\n        // Animate node1 to node2's position\n        node1.transition().duration(1000).attr(\"cx\", node2Position.x).attr(\"cy\", node2Position.y);\n\n        // Animate label1 to node2's position\n        label1.transition().duration(1000).attr(\"x\", node2Position.x).attr(\"y\", node2Position.y);\n\n        // Animate node2 to node1's position\n        node2.transition().duration(1000).attr(\"cx\", node1Position.x).attr(\"cy\", node1Position.y);\n\n        // Animate label2 to node1's position\n        label2.transition().duration(1000).attr(\"x\", node1Position.x).attr(\"y\", node1Position.y);\n        setTimeout(() => resolve(), 1000);\n      });\n    };\n    this.instructions = [];\n    this.current_nodes = [];\n  }\n  add_instruction(instruction) {\n    // Adds it\n    this.instructions.push(instruction);\n  }\n  start_processing() {\n    const svg = d3.select(\"#svg-container\").attr(\"width\", 500).attr(\"height\", 500);\n    this.processInstructions(svg);\n  }\n}","map":{"version":3,"names":["d3","TreeAnimate","constructor","instructions","current_nodes","processInstructions","svg","instruction","type","value","addNode","swapNodes","toIndex","fromIndex","i","index","node","position","getNodePosition","parentIndex","Math","floor","hasParent","Promise","resolve","nodeElement","append","attr","style","label","text","newNode","edge","parentPos","x","y","push","transition","duration","setTimeout","isNaN","depth","log2","xSpacing","ySpacing","isLeftChild","xOffset","nodeA","nodeB","node1","label1","node2","label2","node1Position","parseFloat","node2Position","add_instruction","start_processing","select"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/structures/tree_animator.ts"],"sourcesContent":["import {Instruction, NodeData} from \"../algorithms/tree_intructions\";\r\nimport * as d3 from \"d3\";\r\nimport {BaseType} from \"d3\";\r\n\r\nexport class TreeAnimate {\r\n\r\n    private instructions : Instruction[];\r\n    private current_nodes : NodeData[];\r\n\r\n    constructor() {\r\n        this.instructions = [];\r\n        this.current_nodes = [];\r\n    }\r\n\r\n    add_instruction(instruction : Instruction) {\r\n\r\n        // Adds it\r\n        this.instructions.push(instruction);\r\n    }\r\n\r\n    start_processing() {\r\n        const svg = d3.select(\"#svg-container\")\r\n            .attr(\"width\", 500)\r\n            .attr(\"height\", 500);\r\n\r\n        this.processInstructions(svg);\r\n    }\r\n\r\n    processInstructions = async (svg: d3.Selection<BaseType, unknown, HTMLElement, any>) => {\r\n        for (let instruction of this.instructions) {\r\n            if (instruction.type === 'add' && instruction.value) {\r\n                // Wait for the previous node to finish its animation before adding the next one\r\n                await this.addNode(svg, instruction);\r\n            }\r\n\r\n            if (instruction.type === 'swap') {\r\n\r\n                await this.swapNodes(svg, this.current_nodes[instruction.toIndex as number], this.current_nodes[instruction.fromIndex as number]);\r\n\r\n                const i = this.current_nodes[instruction.toIndex as number].index;\r\n                this.current_nodes[instruction.toIndex as number].index = this.current_nodes[instruction.fromIndex as number].index;\r\n                this.current_nodes[instruction.fromIndex as number].index = i;\r\n\r\n                const node = this.current_nodes[instruction.toIndex as number]\r\n                this.current_nodes[instruction.toIndex as number] = this.current_nodes[instruction.fromIndex as number];\r\n                this.current_nodes[instruction.fromIndex as number] = node;\r\n            }\r\n        }\r\n\r\n        this.instructions = [];\r\n\r\n    };\r\n\r\n    addNode = (svg: d3.Selection<BaseType, unknown, HTMLElement, any>, instruction: Instruction) => {\r\n\r\n        const position = this.getNodePosition(instruction.index as number);\r\n        const parentIndex = Math.floor((instruction.index as number - 1) / 2);\r\n        const hasParent = parentIndex >= 0 && this.current_nodes[parentIndex];\r\n\r\n        return new Promise<void>((resolve) => {\r\n            const nodeElement = svg.append(\"circle\")\r\n                .attr(\"cx\", 200)  // Set starting x position\r\n                .attr(\"cy\", 200)  // Set starting y position\r\n                .attr(\"r\", 20)\r\n                .attr(\"class\", \"node\")\r\n                .style(\"opacity\", 0);  // Start with invisible node\r\n\r\n            const label = svg.append(\"text\")\r\n                .attr(\"x\", 200)  // Same x position as the circle\r\n                .attr(\"y\", 200)  // Same y position as the circle\r\n                .attr(\"class\", \"label\")\r\n                .attr(\"text-anchor\", \"middle\")  // Center the text horizontally\r\n                .attr(\"alignment-baseline\", \"middle\")  // Center the text vertically\r\n                .style(\"fill\", \"white\")  // Set text color\r\n                .style(\"font-size\", \"12px\")\r\n                .text(instruction.value as number | string);\r\n\r\n            const newNode: NodeData = {\r\n                node: nodeElement,\r\n                label: label,\r\n                index: instruction.index as number,\r\n            };\r\n\r\n            let edge: d3.Selection<SVGLineElement, unknown, HTMLElement, any> | null = null;\r\n\r\n            if (hasParent){\r\n                const parentPos = this.getNodePosition(parentIndex as number);\r\n                edge = svg.append(\"line\")\r\n                    .attr(\"x1\", parentPos.x)\r\n                    .attr(\"y1\", parentPos.y)\r\n                    .attr(\"x2\", 200)  // Temporary start position\r\n                    .attr(\"y2\", 200)\r\n                    .attr(\"stroke\", \"white\")\r\n                    .attr(\"stroke-width\", 2)\r\n                    .style(\"opacity\", 0);\r\n            }\r\n\r\n            this.current_nodes.push(newNode);\r\n\r\n            // Animate the node: fade in and move\r\n            nodeElement.transition()\r\n                .duration(1000)  // Duration of 1 second\r\n                .style(\"opacity\", 1)  // Fade in the node\r\n                .attr(\"cx\", position.x)\r\n                .attr(\"cy\", position.y);  // Keep y position constant for simplicity\r\n\r\n            label.transition()\r\n                .duration(1000)  // Duration of 1 second (same as node)\r\n                .style(\"opacity\", 1)\r\n                .attr(\"x\", position.x)\r\n                .attr(\"y\", position.y);\r\n\r\n            // Resolve the promise after the animation duration\r\n            setTimeout(() => resolve(), 1000);  // Wait for the animation to finish (1000ms)\r\n        });\r\n    };\r\n\r\n    getNodePosition = (index: number): { x: number, y: number } => {\r\n        if (index < 0 || isNaN(index)) return { x: 0, y: 0 };\r\n        if (index === 0) return { x: 250, y: 50 }; // Root at the center\r\n\r\n        const depth = Math.floor(Math.log2(index + 1)); // Get depth in the tree\r\n        const xSpacing = (200) / (depth + 1); // Adjust x spacing\r\n        const ySpacing = 80; // Vertical spacing\r\n\r\n        const parentIndex = Math.floor((index - 1) / 2);\r\n        const parentPos = this.getNodePosition(parentIndex);\r\n\r\n        const isLeftChild = index % 2 === 1;\r\n        const xOffset = isLeftChild ? -xSpacing : xSpacing;\r\n\r\n        return { x: parentPos.x + xOffset, y: parentPos.y + ySpacing };\r\n    };\r\n\r\n    swapNodes = (\r\n        svg: d3.Selection<BaseType, unknown, HTMLElement, any>,\r\n        nodeA: NodeData,\r\n        nodeB: NodeData,\r\n    ) => {\r\n\r\n        //alert(nodes.length);\r\n\r\n        return new Promise<void>((resolve) => {\r\n            const node1 = nodeA.node;\r\n            const label1 = nodeA.label;\r\n            const node2 = nodeB.node;\r\n            const label2 = nodeB.label;\r\n\r\n\r\n            const node1Position = { x: parseFloat(node1.attr(\"cx\")), y: parseFloat(node1.attr(\"cy\")) };\r\n            const node2Position = { x: parseFloat(node2.attr(\"cx\")), y: parseFloat(node2.attr(\"cy\")) };\r\n\r\n            // Animate node1 to node2's position\r\n            node1.transition()\r\n                .duration(1000)\r\n                .attr(\"cx\", node2Position.x)\r\n                .attr(\"cy\", node2Position.y);\r\n\r\n            // Animate label1 to node2's position\r\n            label1.transition()\r\n                .duration(1000)\r\n                .attr(\"x\", node2Position.x)\r\n                .attr(\"y\", node2Position.y);\r\n\r\n            // Animate node2 to node1's position\r\n            node2.transition()\r\n                .duration(1000)\r\n                .attr(\"cx\", node1Position.x)\r\n                .attr(\"cy\", node1Position.y);\r\n\r\n            // Animate label2 to node1's position\r\n            label2.transition()\r\n                .duration(1000)\r\n                .attr(\"x\", node1Position.x)\r\n                .attr(\"y\", node1Position.y);\r\n\r\n            setTimeout(() => resolve(), 1000);\r\n        });\r\n    };\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}