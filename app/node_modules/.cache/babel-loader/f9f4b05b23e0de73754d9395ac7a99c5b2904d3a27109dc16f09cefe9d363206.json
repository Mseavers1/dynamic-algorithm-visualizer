{"ast":null,"code":"export class BinaryTree {\n  constructor() {\n    this.values = [];\n    this.length = 0;\n  }\n  clear() {\n    this.values = [];\n    this.length = 0;\n  }\n  get_parent(nodeID) {\n    if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\n    if (this.length <= 0 || nodeID <= 0) return -1;\n    return Math.floor((nodeID - 1) / 2);\n  }\n  get_current_height() {\n    return this.length > 0 ? Math.floor(Math.log2(this.length)) : 0;\n  }\n  is_empty() {\n    return !this.length;\n  }\n  add(value) {\n    this.values.push(value);\n    this.length++;\n  }\n  search(value) {\n    // Convert value to a number if it's a string that can be converted\n    const parsedValue = typeof value === 'string' ? parseFloat(value) : value;\n    for (let i = 0; i < this.length; i++) {\n      const currentValue = this.values[i];\n\n      // If current value is a string that can be converted to a number, convert it\n      const parsedCurrentValue = typeof currentValue === 'string' ? parseFloat(currentValue) : currentValue;\n\n      // Compare the parsed values\n      if (parsedCurrentValue === parsedValue) return i;\n      if (parsedCurrentValue > parsedValue) return -1;\n    }\n    return -1;\n  }\n  remove(index = null) {\n    if (this.length <= 0) throw new Error(\"Cannot remove from an empty tree.\");\n    if (index != null && index >= this.length) throw new Error(\"Index out of range.\");\n    this.length--;\n    if (index == null) return this.values.pop();\n    const val = this.values[index];\n    this.values.splice(index, 1);\n    return val;\n  }\n  swap(nodeA, nodeB) {\n    const a = this.values[nodeA];\n    this.values[nodeA] = this.values[nodeB];\n    this.values[nodeB] = a;\n  }\n  size() {\n    return this.length;\n  }\n  get(nodeID) {\n    if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\n    if (nodeID >= this.length || nodeID < 0) throw new Error(\"NodeID (\" + nodeID.toString() + \") not within range.\");\n    return this.values[nodeID];\n  }\n}","map":{"version":3,"names":["BinaryTree","constructor","values","length","clear","get_parent","nodeID","Number","isInteger","Error","Math","floor","get_current_height","log2","is_empty","add","value","push","search","parsedValue","parseFloat","i","currentValue","parsedCurrentValue","remove","index","pop","val","splice","swap","nodeA","nodeB","a","size","get","toString"],"sources":["C:/Users/Micha/Documents/GitHub/dynamic-algorithm-visualizer/app/src/components/structures/binary_tree.tsx"],"sourcesContent":["import {ITree} from \"./ITree\";\r\nimport {IData} from \"./IData\";\r\n\r\nexport class BinaryTree implements ITree, IData {\r\n    values: (string | number)[] = [];\r\n    length: number = 0;\r\n\r\n    clear(): void {\r\n        this.values = [];\r\n        this.length = 0;\r\n    }\r\n\r\n    get_parent(nodeID: number): number {\r\n        if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\r\n        if (this.length <= 0 || nodeID <= 0) return -1;\r\n        return Math.floor((nodeID - 1) / 2);\r\n    }\r\n\r\n    get_current_height(): number {\r\n        return this.length > 0 ? Math.floor(Math.log2(this.length)) : 0;\r\n    }\r\n\r\n    is_empty(): boolean {\r\n        return !this.length;\r\n    }\r\n\r\n    add(value: string | number): void {\r\n        this.values.push(value);\r\n        this.length++;\r\n    }\r\n\r\n    search(value: string | number): number {\r\n        // Convert value to a number if it's a string that can be converted\r\n        const parsedValue = typeof value === 'string' ? parseFloat(value) : value;\r\n\r\n        for (let i = 0; i < this.length; i++) {\r\n            const currentValue = this.values[i];\r\n\r\n            // If current value is a string that can be converted to a number, convert it\r\n            const parsedCurrentValue = typeof currentValue === 'string' ? parseFloat(currentValue) : currentValue;\r\n\r\n            // Compare the parsed values\r\n            if (parsedCurrentValue === parsedValue) return i;\r\n            if (parsedCurrentValue > parsedValue) return -1;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n\r\n    remove(index: number | null = null): string | number {\r\n        if (this.length <= 0) throw new Error(\"Cannot remove from an empty tree.\");\r\n        if (index != null && index >= this.length) throw new Error(\"Index out of range.\");\r\n        this.length--;\r\n        if (index == null) return this.values.pop() as string | number;\r\n        const val = this.values[index];\r\n        this.values.splice(index, 1);\r\n        return val;\r\n    }\r\n\r\n    swap(nodeA: number, nodeB: number): void {\r\n        const a = this.values[nodeA];\r\n        this.values[nodeA] = this.values[nodeB];\r\n        this.values[nodeB] = a;\r\n    }\r\n\r\n    size(): number {\r\n        return this.length;\r\n    }\r\n\r\n    get(nodeID: number): number | string {\r\n        if (!Number.isInteger(nodeID)) throw new Error(\"NodeID must be an integer.\");\r\n        if (nodeID >= this.length || nodeID < 0) throw new Error(\"NodeID (\" + nodeID.toString() + \") not within range.\");\r\n        return this.values[nodeID];\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}